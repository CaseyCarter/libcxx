// -*- C++ -*-
//===-------------------------- iterator ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_ITERATOR
#define _LIBCPP_ITERATOR

/*
    iterator synopsis

namespace std
{

template <class Iterator>
struct iterator_traits
{
    typedef typename Iterator::difference_type difference_type;
    typedef typename Iterator::value_type value_type;
    typedef typename Iterator::pointer pointer;
    typedef typename Iterator::reference reference;
    typedef typename Iterator::iterator_category iterator_category;
};

template <class T>
struct iterator_traits<T*>
{
    typedef ptrdiff_t difference_type;
    typedef T value_type;
    typedef T* pointer;
    typedef T& reference;
    typedef random_access_iterator_tag iterator_category;
};

template <class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator
{
    typedef T         value_type;
    typedef Distance  difference_type;
    typedef Pointer   pointer;
    typedef Reference reference;
    typedef Category  iterator_category;
};

struct input_iterator_tag  {};
struct output_iterator_tag {};
struct forward_iterator_tag       : public input_iterator_tag         {};
struct bidirectional_iterator_tag : public forward_iterator_tag       {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};

// 27.4.3, iterator operations
// extension: second argument not conforming to C++03
template <class InputIterator>  // constexpr in C++17
  constexpr void advance(InputIterator& i,
             typename iterator_traits<InputIterator>::difference_type n);

template <class InputIterator>  // constexpr in C++17
  constexpr typename iterator_traits<InputIterator>::difference_type
    distance(InputIterator first, InputIterator last);

template <class InputIterator>  // constexpr in C++17
  constexpr InputIterator next(InputIterator x,
typename iterator_traits<InputIterator>::difference_type n = 1);

template <class BidirectionalIterator>  // constexpr in C++17
  constexpr BidirectionalIterator prev(BidirectionalIterator x,
    typename iterator_traits<BidirectionalIterator>::difference_type n = 1);

template <class Iterator>
class reverse_iterator
    : public iterator<typename iterator_traits<Iterator>::iterator_category,
                      typename iterator_traits<Iterator>::value_type,
                      typename iterator_traits<Iterator>::difference_type,
                      typename iterator_traits<Iterator>::pointer,
                      typename iterator_traits<Iterator>::reference>
{
protected:
    Iterator current;
public:
    typedef Iterator                                            iterator_type;
    typedef typename iterator_traits<Iterator>::difference_type difference_type;
    typedef typename iterator_traits<Iterator>::reference       reference;
    typedef typename iterator_traits<Iterator>::pointer         pointer;

    constexpr reverse_iterator();
    constexpr explicit reverse_iterator(Iterator x);
    template <class U> constexpr reverse_iterator(const reverse_iterator<U>& u);
    template <class U> constexpr reverse_iterator& operator=(const reverse_iterator<U>& u);
    constexpr Iterator base() const;
    constexpr reference operator*() const;
    constexpr pointer   operator->() const;
    constexpr reverse_iterator& operator++();
    constexpr reverse_iterator  operator++(int);
    constexpr reverse_iterator& operator--();
    constexpr reverse_iterator  operator--(int);
    constexpr reverse_iterator  operator+ (difference_type n) const;
    constexpr reverse_iterator& operator+=(difference_type n);
    constexpr reverse_iterator  operator- (difference_type n) const;
    constexpr reverse_iterator& operator-=(difference_type n);
    constexpr reference         operator[](difference_type n) const;
};

template <class Iterator1, class Iterator2>
constexpr bool                          // constexpr in C++17
operator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool                          // constexpr in C++17
operator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool                          // constexpr in C++17
operator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool                          // constexpr in C++17
operator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool                          // constexpr in C++17
operator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool                          // constexpr in C++17
operator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr auto
operator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y)
-> decltype(__y.base() - __x.base());   // constexpr in C++17

template <class Iterator>
constexpr reverse_iterator<Iterator>
operator+(typename reverse_iterator<Iterator>::difference_type n,
          const reverse_iterator<Iterator>& x);   // constexpr in C++17

template <class Iterator>
constexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14, constexpr in C++17

template <class Container>
class back_insert_iterator
{
protected:
    Container* container;
public:
    typedef Container                   container_type;
    typedef void                        value_type;
    typedef void                        difference_type;
    typedef void                        reference;
    typedef void                        pointer;

    explicit back_insert_iterator(Container& x);
    back_insert_iterator& operator=(const typename Container::value_type& value);
    back_insert_iterator& operator*();
    back_insert_iterator& operator++();
    back_insert_iterator  operator++(int);
};

template <class Container> back_insert_iterator<Container> back_inserter(Container& x);

template <class Container>
class front_insert_iterator
{
protected:
    Container* container;
public:
    typedef Container                    container_type;
    typedef void                         value_type;
    typedef void                         difference_type;
    typedef void                         reference;
    typedef void                         pointer;

    explicit front_insert_iterator(Container& x);
    front_insert_iterator& operator=(const typename Container::value_type& value);
    front_insert_iterator& operator*();
    front_insert_iterator& operator++();
    front_insert_iterator  operator++(int);
};

template <class Container> front_insert_iterator<Container> front_inserter(Container& x);

template <class Container>
class insert_iterator
{
protected:
    Container* container;
    typename Container::iterator iter;
public:
    typedef Container              container_type;
    typedef void                   value_type;
    typedef void                   difference_type;
    typedef void                   reference;
    typedef void                   pointer;

    insert_iterator(Container& x, typename Container::iterator i);
    insert_iterator& operator=(const typename Container::value_type& value);
    insert_iterator& operator*();
    insert_iterator& operator++();
    insert_iterator& operator++(int);
};

template <class Container, class Iterator>
insert_iterator<Container> inserter(Container& x, Iterator i);

template <class Iterator>
class move_iterator {
public:
    typedef Iterator                                              iterator_type;
    typedef typename iterator_traits<Iterator>::difference_type   difference_type;
    typedef Iterator                                              pointer;
    typedef typename iterator_traits<Iterator>::value_type        value_type;
    typedef typename iterator_traits<Iterator>::iterator_category iterator_category;
    typedef value_type&&                                          reference;

    constexpr move_iterator();  // all the constexprs are in C++17
    constexpr explicit move_iterator(Iterator i);
    template <class U>
      constexpr move_iterator(const move_iterator<U>& u);
    template <class U>
      constexpr move_iterator& operator=(const move_iterator<U>& u);
    constexpr iterator_type base() const;
    constexpr reference operator*() const;
    constexpr pointer operator->() const;
    constexpr move_iterator& operator++();
    constexpr move_iterator operator++(int);
    constexpr move_iterator& operator--();
    constexpr move_iterator operator--(int);
    constexpr move_iterator operator+(difference_type n) const;
    constexpr move_iterator& operator+=(difference_type n);
    constexpr move_iterator operator-(difference_type n) const;
    constexpr move_iterator& operator-=(difference_type n);
    constexpr unspecified operator[](difference_type n) const;
private:
    Iterator current; // exposition only
};

template <class Iterator1, class Iterator2>
constexpr bool   // constexpr in C++17
operator==(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool   // constexpr in C++17
operator!=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool   // constexpr in C++17
operator<(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool   // constexpr in C++17
operator<=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool   // constexpr in C++17
operator>(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool   // constexpr in C++17
operator>=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr auto   // constexpr in C++17
operator-(const move_iterator<Iterator1>& x,
          const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());

template <class Iterator>
constexpr move_iterator<Iterator> operator+(   // constexpr in C++17
            typename move_iterator<Iterator>::difference_type n,
            const move_iterator<Iterator>& x);

template <class Iterator>   // constexpr in C++17
constexpr  move_iterator<Iterator> make_move_iterator(const Iterator& i);


template <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>
class istream_iterator
    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>
{
public:
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_istream<charT,traits> istream_type;

    constexpr istream_iterator();
    istream_iterator(istream_type& s);
    istream_iterator(const istream_iterator& x);
    ~istream_iterator();

    const T& operator*() const;
    const T* operator->() const;
    istream_iterator& operator++();
    istream_iterator  operator++(int);
};

template <class T, class charT, class traits, class Distance>
bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
                const istream_iterator<T,charT,traits,Distance>& y);
template <class T, class charT, class traits, class Distance>
bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,
                const istream_iterator<T,charT,traits,Distance>& y);

template <class T, class charT = char, class traits = char_traits<charT> >
class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void ,void>
{
public:
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_ostream<charT,traits> ostream_type;

    ostream_iterator(ostream_type& s);
    ostream_iterator(ostream_type& s, const charT* delimiter);
    ostream_iterator(const ostream_iterator& x);
    ~ostream_iterator();
    ostream_iterator& operator=(const T& value);

    ostream_iterator& operator*();
    ostream_iterator& operator++();
    ostream_iterator& operator++(int);
};

template <class charT, class traits = char_traits<charT> >
class istreambuf_iterator
    : public iterator<input_iterator_tag, charT,
                      typename traits::off_type, unspecified,
                      charT>
{
public:
    typedef charT                         char_type;
    typedef traits                        traits_type;
    typedef typename traits::int_type     int_type;
    typedef basic_streambuf<charT,traits> streambuf_type;
    typedef basic_istream<charT,traits>   istream_type;

    istreambuf_iterator() noexcept;
    istreambuf_iterator(istream_type& s) noexcept;
    istreambuf_iterator(streambuf_type* s) noexcept;
    istreambuf_iterator(a-private-type) noexcept;

    charT                operator*() const;
    pointer operator->() const;
    istreambuf_iterator& operator++();
    a-private-type       operator++(int);

    bool equal(const istreambuf_iterator& b) const;
};

template <class charT, class traits>
bool operator==(const istreambuf_iterator<charT,traits>& a,
                const istreambuf_iterator<charT,traits>& b);
template <class charT, class traits>
bool operator!=(const istreambuf_iterator<charT,traits>& a,
                const istreambuf_iterator<charT,traits>& b);

template <class charT, class traits = char_traits<charT> >
class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef charT                         char_type;
    typedef traits                        traits_type;
    typedef basic_streambuf<charT,traits> streambuf_type;
    typedef basic_ostream<charT,traits>   ostream_type;

    ostreambuf_iterator(ostream_type& s) noexcept;
    ostreambuf_iterator(streambuf_type* s) noexcept;
    ostreambuf_iterator& operator=(charT c);
    ostreambuf_iterator& operator*();
    ostreambuf_iterator& operator++();
    ostreambuf_iterator& operator++(int);
    bool failed() const noexcept;
};

template <class C> constexpr auto begin(C& c) -> decltype(c.begin());
template <class C> constexpr auto begin(const C& c) -> decltype(c.begin());
template <class C> constexpr auto end(C& c) -> decltype(c.end());
template <class C> constexpr auto end(const C& c) -> decltype(c.end());
template <class T, size_t N> constexpr T* begin(T (&array)[N]);
template <class T, size_t N> constexpr T* end(T (&array)[N]);

template <class C> auto constexpr cbegin(const C& c) -> decltype(std::begin(c));        // C++14
template <class C> auto constexpr cend(const C& c) -> decltype(std::end(c));            // C++14
template <class C> auto constexpr rbegin(C& c) -> decltype(c.rbegin());                 // C++14
template <class C> auto constexpr rbegin(const C& c) -> decltype(c.rbegin());           // C++14
template <class C> auto constexpr rend(C& c) -> decltype(c.rend());                     // C++14
template <class C> constexpr auto rend(const C& c) -> decltype(c.rend());               // C++14
template <class E> reverse_iterator<const E*> constexpr rbegin(initializer_list<E> il); // C++14
template <class E> reverse_iterator<const E*> constexpr rend(initializer_list<E> il);   // C++14
template <class T, size_t N> reverse_iterator<T*> constexpr rbegin(T (&array)[N]);      // C++14
template <class T, size_t N> reverse_iterator<T*> constexpr rend(T (&array)[N]);        // C++14
template <class C> constexpr auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14
template <class C> constexpr auto crend(const C& c) -> decltype(std::rend(c));          // C++14

// 24.8, container access:
template <class C> constexpr auto size(const C& c) -> decltype(c.size());         // C++17
template <class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept; // C++17
template <class C> constexpr auto empty(const C& c) -> decltype(c.empty());       // C++17
template <class T, size_t N> constexpr bool empty(const T (&array)[N]) noexcept;  // C++17
template <class E> constexpr bool empty(initializer_list<E> il) noexcept;         // C++17
template <class C> constexpr auto data(C& c) -> decltype(c.data());               // C++17
template <class C> constexpr auto data(const C& c) -> decltype(c.data());         // C++17
template <class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;           // C++17
template <class E> constexpr const E* data(initializer_list<E> il) noexcept;      // C++17

}  // std

*/

#include <__config>
#include <iosfwd> // for forward declarations of vector and string.
#include <__functional_base>
#include <type_traits>
#include <cstddef>
#include <initializer_list>
#include <version>
#ifdef __APPLE__
#include <Availability.h>
#endif

#ifdef _LIBCPP_HAS_RANGES
#include <concepts>
#endif

#include <__debug>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_BEGIN_NAMESPACE_STD

#if _LIBCPP_STD_VER > 11
template <class _Iter> class _LIBCPP_TEMPLATE_VIS reverse_iterator;

template <class _Iter>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
reverse_iterator<_Iter> make_reverse_iterator(_Iter __i)
    _NOEXCEPT_((is_nothrow_constructible<reverse_iterator<_Iter>, _Iter>::value))
{
    return reverse_iterator<_Iter>(std::move(__i));
}
#endif

template <class _Category, class _Tp, class _Distance = ptrdiff_t,
         class _Pointer = _Tp*, class _Reference = _Tp&>
struct _LIBCPP_TEMPLATE_VIS iterator
{
    typedef _Tp        value_type;
    typedef _Distance  difference_type;
    typedef _Pointer   pointer;
    typedef _Reference reference;
    typedef _Category  iterator_category;
};

struct _LIBCPP_TEMPLATE_VIS input_iterator_tag {};
struct _LIBCPP_TEMPLATE_VIS output_iterator_tag {};
struct _LIBCPP_TEMPLATE_VIS forward_iterator_tag       : public input_iterator_tag {};
struct _LIBCPP_TEMPLATE_VIS bidirectional_iterator_tag : public forward_iterator_tag {};
struct _LIBCPP_TEMPLATE_VIS random_access_iterator_tag : public bidirectional_iterator_tag {};

#ifdef _LIBCPP_HAS_RANGES
struct _LIBCPP_TEMPLATE_VIS contiguous_iterator_tag    : public random_access_iterator_tag {};

template <class _Fn, class... _Args>
using __apply = typename _Fn::template __apply<_Args...>;

template <bool>
struct __select_
{
    template <class, class _Tp> using __apply = _Tp;
};

template <>
struct __select_<true>
{
    template <class _Tp, class> using __apply = _Tp;
};

template <bool _Cond, class _Tp, class _Fp>
using __select = __apply<__select_<_Cond>, _Tp, _Fp>;

template <class _Tp> using __reference_to = _Tp&;

template <class _Tp>
_LIBCPP_CONCEPT_DECL __can_reference = // FIXME: specify this
    requires { typename __reference_to<_Tp>; };

template <class _Tp>
_LIBCPP_CONCEPT_DECL __dereferenceable =
    requires(_Tp& __t) { { *__t } -> __can_reference&&; };

template <class _Tp> struct _LIBCPP_TEMPLATE_VIS iterator_traits {
    using __is_not_specialized = iterator_traits<_Tp>;
};

template <class> struct _LIBCPP_TEMPLATE_VIS incrementable_traits {};

template <class _Tp>
requires is_object_v<_Tp>
struct _LIBCPP_TEMPLATE_VIS incrementable_traits<_Tp*> {
    using difference_type = ptrdiff_t;
};

template <class _Tp>
_LIBCPP_CONCEPT_DECL __has_member_difference_type =
    requires { typename _Tp::difference_type; };

template <class _Tp>
struct _LIBCPP_TEMPLATE_VIS incrementable_traits<const _Tp>
    : incrementable_traits<decay_t<_Tp>>
{};

template <__has_member_difference_type _Tp>
struct _LIBCPP_TEMPLATE_VIS incrementable_traits<_Tp>
{
    using difference_type = typename _Tp::difference_type;
};

template <class _Tp>
_LIBCPP_CONCEPT_DECL __can_difference =
    requires(const _Tp& __x, const _Tp& __y) {
        { __x - __y } -> Integral;
    };

template <class _Tp>
requires !__has_member_difference_type<_Tp> &&
#if !defined(__clang__) && defined(__GNUC__)
    // workaround https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78173
    !is_pointer_v<_Tp> &&
#endif
    __can_difference<_Tp>
struct _LIBCPP_TEMPLATE_VIS incrementable_traits<_Tp>
{
    using difference_type = make_signed_t<
        decltype(_VSTD::declval<_Tp>() - _VSTD::declval<_Tp>())>;
};

template <class _Tp>
_LIBCPP_CONCEPT_DECL __is_not_specialized = requires {
    typename _Tp::__is_not_specialized;
    requires Same<_Tp, typename _Tp::__is_not_specialized>;
};

template <class _Tp>
using iter_difference_t = typename __select<
    __is_not_specialized<iterator_traits<_Tp>>,
    incrementable_traits<_Tp>,
    iterator_traits<_Tp>>::difference_type;

template <class> struct _LIBCPP_TEMPLATE_VIS readable_traits {};

template <class _Tp>
struct _LIBCPP_TEMPLATE_VIS readable_traits<_Tp*>
{};

template <class _Tp>
requires is_object_v<_Tp>
struct _LIBCPP_TEMPLATE_VIS readable_traits<_Tp*>
{
    using value_type = remove_cv_t<_Tp>;
};

template <class _Tp>
requires is_array_v<_Tp>
struct _LIBCPP_TEMPLATE_VIS readable_traits<_Tp>
    : readable_traits<decay_t<_Tp>>
{};

template <class _Tp>
struct _LIBCPP_TEMPLATE_VIS readable_traits<const _Tp>
    : readable_traits<_Tp>
{};

template <class _Tp>
_LIBCPP_CONCEPT_DECL __has_member_value_type =
    requires { typename _Tp::value_type; };

template <__has_member_value_type _Tp>
struct _LIBCPP_TEMPLATE_VIS readable_traits<_Tp>
{};

template <__has_member_value_type _Tp>
requires is_object_v<typename _Tp::value_type>
struct _LIBCPP_TEMPLATE_VIS readable_traits<_Tp>
{
    using value_type = remove_cv_t<typename _Tp::value_type>;
};

template <class _Tp>
_LIBCPP_CONCEPT_DECL __has_member_element_type =
    requires { typename _Tp::element_type; };

template <__has_member_element_type _Tp>
struct _LIBCPP_TEMPLATE_VIS readable_traits<_Tp>
{};

template <__has_member_element_type _Tp>
requires is_object_v<typename _Tp::element_type>
struct _LIBCPP_TEMPLATE_VIS readable_traits<_Tp>
{
    using value_type = remove_cv_t<typename _Tp::element_type>;
};

template <class _Tp>
using iter_value_t = typename __select<
    __is_not_specialized<iterator_traits<_Tp>>,
    readable_traits<_Tp>,
    iterator_traits<_Tp>>::value_type;

template <__dereferenceable _Tp>
using iter_reference_t = decltype(*_VSTD::declval<_Tp&>());

namespace ranges
{
    namespace __iter_move
    {
        void iter_move() = delete; // Block unqualified lookup

        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __has_adl = requires(_Tp&& __t) {
            iter_move(static_cast<_Tp&&>(__t));
        };

        struct __fn
        {
            template <class _Tp>
            requires __has_adl<_Tp>
            constexpr decltype(auto) operator()(_Tp&& __t) const
                _NOEXCEPT_(noexcept(iter_move(static_cast<_Tp&&>(__t))))
            {
                return iter_move(static_cast<_Tp&&>(__t));
            }

            template <class _Tp>
            requires !__has_adl<_Tp> &&
                requires(_Tp&& __t) { *static_cast<_Tp&&>(__t); }
            constexpr decltype(auto) operator()(_Tp&& __t) const
                _NOEXCEPT_(noexcept(*static_cast<_Tp&&>(__t)))
            {
                using _Ref = decltype(*static_cast<_Tp&&>(__t));
                if constexpr (is_lvalue_reference_v<_Ref>) {
                    return _VSTD::move(*static_cast<_Tp&&>(__t));
                } else {
                    return *static_cast<_Tp&&>(__t);
                }
            }
        };
    }

    inline namespace __cpos {
        inline constexpr __iter_move::__fn iter_move{};
    }
}

template <__dereferenceable _Tp>
requires requires (_Tp& __t) {
    { _VSTD::ranges::iter_move(__t) } -> __can_reference&&;
}
using iter_rvalue_reference_t =
    decltype(_VSTD::ranges::iter_move(_VSTD::declval<_Tp&>()));

template <class _Iter>
_LIBCPP_CONCEPT_DECL Readable =
    requires {
        typename iter_value_t<_Iter>;
        typename iter_reference_t<_Iter>;
        typename iter_rvalue_reference_t<_Iter>;
    } &&
    CommonReference<iter_reference_t<_Iter>&&, iter_value_t<_Iter>&> &&
    CommonReference<iter_reference_t<_Iter>&&, iter_rvalue_reference_t<_Iter>&&> &&
    CommonReference<iter_rvalue_reference_t<_Iter>&&, const iter_value_t<_Iter>&>;

template <Readable _Tp>
using iter_common_reference_t =
    common_reference_t<iter_reference_t<_Tp>, iter_value_t<_Tp>&>;

template <class _Iter, class _Tp>
_LIBCPP_CONCEPT_DECL Writable =
    requires(_Iter&& __i, _Tp&& __t) {
        *__i = static_cast<_Tp&&>(__t);
        *static_cast<_Iter&&>(__i) = static_cast<_Tp&&>(__t);
        const_cast<const iter_reference_t<_Iter>&&>(*__i) =
            static_cast<_Tp&&>(__t);
        const_cast<const iter_reference_t<_Iter>&&>(*static_cast<_Iter&&>(__i)) =
            static_cast<_Tp&&>(__t);
    };

template <class _Tp>
_LIBCPP_CONCEPT_DECL WeaklyIncrementable =
    Semiregular<_Tp> && requires(_Tp __i) {
        typename iter_difference_t<_Tp>;
        requires SignedIntegral<iter_difference_t<_Tp>>;
        { ++__i } -> Same<_Tp>&;
        __i++;
    };

template <class _Tp>
_LIBCPP_CONCEPT_DECL Incrementable =
    Regular<_Tp> && WeaklyIncrementable<_Tp> && requires(_Tp __t) {
        __t++; requires Same<decltype(__t++), _Tp>;
    };

template <class _Iter>
_LIBCPP_CONCEPT_DECL Iterator =
    requires(_Iter __i) {
        { *__i } -> __can_reference&&;
        requires WeaklyIncrementable<_Iter>;
    };

template <class _Sent, class _Iter>
_LIBCPP_CONCEPT_DECL Sentinel =
    Semiregular<_Sent> && Iterator<_Iter> &&
    __weakly_equality_comparable<_Sent, _Iter>;

template <class _Sent, class _Iter>
inline constexpr bool disable_sized_sentinel = false;

template <class _Sent, class _Iter>
_LIBCPP_CONCEPT_DECL SizedSentinel =
    Sentinel<_Sent, _Iter> &&
    !disable_sized_sentinel<remove_cv_t<_Sent>, remove_cv_t<_Iter>> &&
    requires(const _Iter& __i, const _Sent& __s) {
        __s - __i; requires Same<decltype(__s - __i), iter_difference_t<_Iter>>;
        __i - __s; requires Same<decltype(__i - __s), iter_difference_t<_Iter>>;
    };

template <class _Tp>
_LIBCPP_CONCEPT_DECL __has_member_pointer =
    requires { typename _Tp::pointer; };

template <class _Tp>
_LIBCPP_CONCEPT_DECL __has_member_reference =
    requires { typename _Tp::reference; };

template <class _Tp>
_LIBCPP_CONCEPT_DECL __has_member_category =
    requires { typename _Tp::iterator_category; };

template <class _Tp>
_LIBCPP_CONCEPT_DECL __has_member_iter_concept =
    requires { typename _Tp::iterator_concept; };

template <class _Iter, bool _NotSpec = __is_not_specialized<iterator_traits<_Iter>>>
struct __iter_concept_
{};

template <class _Iter>
requires __has_member_iter_concept<iterator_traits<_Iter>>
struct __iter_concept_<_Iter, false>
{
    using type = typename iterator_traits<_Iter>::iterator_concept;
};

template <class _Iter>
requires !__has_member_iter_concept<iterator_traits<_Iter>> &&
    __has_member_category<iterator_traits<_Iter>>
struct __iter_concept_<_Iter, false>
{
    using type = typename iterator_traits<_Iter>::iterator_category;
};

template <class _Iter>
struct __iter_concept_<_Iter, true>
{
    using type = random_access_iterator_tag;
};

template <__has_member_iter_concept _Iter>
struct __iter_concept_<_Iter, true>
{
    using type = typename _Iter::iterator_concept;
};

template <class _Iter>
requires !__has_member_iter_concept<_Iter> && __has_member_category<_Iter>
struct __iter_concept_<_Iter, true>
{
    using type = typename _Iter::iterator_category;
};

template <class _Iter>
using __iter_concept = typename __iter_concept_<_Iter>::type;

template <class _Iter>
_LIBCPP_CONCEPT_DECL InputIterator =
    Iterator<_Iter> && Readable<_Iter> &&
    requires { typename __iter_concept<_Iter>; } &&
    DerivedFrom<__iter_concept<_Iter>, input_iterator_tag>;

template <class _Iter, class _Tp>
_LIBCPP_CONCEPT_DECL OutputIterator =
    Iterator<_Iter> && Writable<_Iter, _Tp> && requires(_Iter __i, _Tp&& __t) {
        *__i++ = static_cast<_Tp&&>(__t);
    };

template <class _Iter>
_LIBCPP_CONCEPT_DECL ForwardIterator =
    InputIterator<_Iter> &&
    DerivedFrom<__iter_concept<_Iter>, forward_iterator_tag> &&
    Incrementable<_Iter> &&
    Sentinel<_Iter, _Iter>;

template <class _Iter>
_LIBCPP_CONCEPT_DECL BidirectionalIterator =
    ForwardIterator<_Iter> &&
    DerivedFrom<__iter_concept<_Iter>, bidirectional_iterator_tag> &&
    requires(_Iter __i) {
        { --__i } -> Same<_Iter>&;
        __i--; requires Same<decltype(__i--), _Iter>;
    };

template <class _Iter>
_LIBCPP_CONCEPT_DECL RandomAccessIterator =
    BidirectionalIterator<_Iter> &&
    DerivedFrom<__iter_concept<_Iter>, random_access_iterator_tag> &&
    StrictTotallyOrdered<_Iter> &&
    SizedSentinel<_Iter, _Iter> &&
    requires(_Iter __i, const _Iter __j, const iter_difference_t<_Iter> __n) {
        { __i += __n } -> Same<_Iter>&;
        __j + __n; requires Same<decltype(__j + __n), _Iter>;
        __n + __j; requires Same<decltype(__n + __j), _Iter>;
        { __i -= __n } -> Same<_Iter>&;
        __j - __n; requires Same<decltype(__j - __n), _Iter>;
        __j[__n]; requires Same<decltype(__j[__n]), iter_reference_t<_Iter>>;
    };

template <class _Iter>
_LIBCPP_CONCEPT_DECL ContiguousIterator =
    RandomAccessIterator<_Iter> &&
    DerivedFrom<__iter_concept<_Iter>, contiguous_iterator_tag> &&
    is_lvalue_reference_v<iter_reference_t<_Iter>> &&
    Same<iter_value_t<_Iter>, remove_cvref_t<iter_reference_t<_Iter>>>;

template <class _Fn, class _Iter>
_LIBCPP_CONCEPT_DECL IndirectUnaryInvocable =
    Readable<_Iter> && CopyConstructible<_Fn> &&
    Invocable<_Fn&, iter_value_t<_Iter>&> &&
    Invocable<_Fn&, iter_reference_t<_Iter>> &&
    Invocable<_Fn&, iter_common_reference_t<_Iter>> &&
    CommonReference<
        invoke_result_t<_Fn&, iter_value_t<_Iter>&>,
        invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;

template <class _Fn, class _Iter>
_LIBCPP_CONCEPT_DECL IndirectRegularUnaryInvocable =
    Readable<_Iter> && CopyConstructible<_Fn> &&
    RegularInvocable<_Fn&, iter_value_t<_Iter>&> &&
    RegularInvocable<_Fn&, iter_reference_t<_Iter>> &&
    RegularInvocable<_Fn&, iter_common_reference_t<_Iter>> &&
    CommonReference<
        invoke_result_t<_Fn&, iter_value_t<_Iter>&>,
        invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;

template <class _Fn, class _Iter>
_LIBCPP_CONCEPT_DECL IndirectUnaryPredicate =
    Readable<_Iter> && CopyConstructible<_Fn> &&
    Predicate<_Fn&, iter_value_t<_Iter>&> &&
    Predicate<_Fn&, iter_reference_t<_Iter>> &&
    Predicate<_Fn&, iter_common_reference_t<_Iter>>;

template <class _Fn, class _Iter1, class _Iter2 = _Iter1>
_LIBCPP_CONCEPT_DECL IndirectRelation =
    Readable<_Iter1> && Readable<_Iter2> && CopyConstructible<_Fn> &&
    Relation<_Fn&, iter_value_t<_Iter1>&, iter_value_t<_Iter2>&> &&
    Relation<_Fn&, iter_value_t<_Iter1>&, iter_reference_t<_Iter2>> &&
    Relation<_Fn&, iter_reference_t<_Iter1>, iter_value_t<_Iter2>&> &&
    Relation<_Fn&, iter_reference_t<_Iter1>, iter_reference_t<_Iter2>> &&
    Relation<_Fn&, iter_common_reference_t<_Iter1>, iter_common_reference_t<_Iter2>>;

template <class _Fn, class _Iter1, class _Iter2 = _Iter1>
_LIBCPP_CONCEPT_DECL IndirectStrictWeakOrder =
    Readable<_Iter1> && Readable<_Iter2> && CopyConstructible<_Fn> &&
    StrictWeakOrder<_Fn&, iter_value_t<_Iter1>&, iter_value_t<_Iter2>&> &&
    StrictWeakOrder<_Fn&, iter_value_t<_Iter1>&, iter_reference_t<_Iter2>> &&
    StrictWeakOrder<_Fn&, iter_reference_t<_Iter1>, iter_value_t<_Iter2>&> &&
    StrictWeakOrder<_Fn&, iter_reference_t<_Iter1>, iter_reference_t<_Iter2>> &&
    StrictWeakOrder<_Fn&, iter_common_reference_t<_Iter1>, iter_common_reference_t<_Iter2>>;

template <class _Fn, class... _Iters>
    requires (Readable<_Iters> && ...) && Invocable<_Fn, iter_reference_t<_Iters>...>
using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Iters>...>;

template <Readable _Iter, IndirectUnaryInvocable<_Iter> _Proj>
struct projected
{
    using value_type = remove_cvref_t<indirect_result_t<_Proj&, _Iter>>;
    indirect_result_t<_Proj&, _Iter> operator*() const;
};

template <WeaklyIncrementable _Iter, class _Proj>
struct incrementable_traits<projected<_Iter, _Proj>>
{
    using difference_type = iter_difference_t<_Iter>;
};

template <class _In, class _Out>
_LIBCPP_CONCEPT_DECL IndirectlyMovable =
    Readable<_In> && Writable<_Out, iter_rvalue_reference_t<_In>>;

template <class _In, class _Out>
_LIBCPP_CONCEPT_DECL IndirectlyMovableStorable =
    IndirectlyMovable<_In, _Out> &&
    Writable<_Out, iter_value_t<_In>> &&
    Movable<iter_value_t<_In>> &&
    Constructible<iter_value_t<_In>, iter_rvalue_reference_t<_In>> &&
    Assignable<iter_value_t<_In>&, iter_rvalue_reference_t<_In>>;

template <class _In, class _Out>
_LIBCPP_CONCEPT_DECL IndirectlyCopyable =
    Readable<_In> && Writable<_Out, iter_reference_t<_In>>;

template <class _In, class _Out>
_LIBCPP_CONCEPT_DECL IndirectlyCopyableStorable =
    IndirectlyCopyable<_In, _Out> &&
    Writable<_Out, const iter_value_t<_In>&> &&
    Copyable<iter_value_t<_In>> &&
    Constructible<iter_value_t<_In>, iter_reference_t<_In>> &&
    Assignable<iter_value_t<_In>&, iter_reference_t<_In>>;

namespace ranges
{
    namespace __iter_swap
    {
        template <class _Tp, class _Up>
        void iter_swap(_Tp, _Up) = delete;

        template <class _Tp, class _Up>
        _LIBCPP_CONCEPT_DECL __has_adl = requires(_Tp&& __t, _Up&& __u) {
            iter_swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
        };

        template <class _Tp, class _Up>
        _LIBCPP_CONCEPT_DECL __can_swap_references =
            Readable<remove_reference_t<_Tp>> &&
            Readable<remove_reference_t<_Up>> &&
            SwappableWith<iter_reference_t<_Tp>, iter_reference_t<_Up>>;

        template <class _Tp, class _Up>
        inline constexpr bool __ne = conjunction_v<
            is_nothrow_constructible<iter_value_t<_Tp>, iter_rvalue_reference_t<_Tp>>,
            is_nothrow_assignable<iter_value_t<_Tp>&, iter_rvalue_reference_t<_Tp>>,
            is_nothrow_assignable<iter_reference_t<_Tp>, iter_rvalue_reference_t<_Up>>,
            is_nothrow_assignable<iter_reference_t<_Tp>, iter_value_t<_Up>>,
            is_nothrow_move_constructible<iter_value_t<_Tp>>,
            bool_constant<_NOEXCEPT_(iter_move(_VSTD::declval<_Tp&>()))>>;

        template <class _Tp, class _Up>
        constexpr iter_value_t<_Tp> __iter_exchange_move(_Tp& __t, _Up& __u)
            _NOEXCEPT_(noexcept(__ne<_Tp, _Up> && __ne<_Up, _Tp>))
        {
            iter_value_t<_Tp> __tmp(iter_move(__t));
            *__t = iter_move(__u);
            return __tmp;
        }

        struct __fn
        {
            template <class _Tp, class _Up>
            requires __has_adl<_Tp, _Up>
            constexpr void operator()(_Tp&& __t, _Up&& __u) const
                _NOEXCEPT_(noexcept(iter_swap(
                    static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u))))
            {
                iter_swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
            }

            template <class _Tp, class _Up>
            requires !__has_adl<_Tp, _Up> && __can_swap_references<_Tp, _Up>
            constexpr void operator()(_Tp&& __t, _Up&& __u) const
                _NOEXCEPT_(noexcept(swap(
                    *static_cast<_Tp&&>(__t), *static_cast<_Up&&>(__u))))
            {
                swap(*static_cast<_Tp&&>(__t), *static_cast<_Up&&>(__u));
            }

            template <class _Tp, class _Up>
            requires !__has_adl<_Tp, _Up> && !__can_swap_references<_Tp, _Up> &&
                IndirectlyMovableStorable<
                    remove_reference_t<_Tp>, remove_reference_t<_Up>> &&
                IndirectlyMovableStorable<
                    remove_reference_t<_Up>, remove_reference_t<_Tp>>
            constexpr void operator()(_Tp&& __t, _Up&& __u) const
                _NOEXCEPT_(noexcept(
                    *static_cast<_Tp&&>(__t) = __iter_exchange_move(__u, __t)))
            {
                *static_cast<_Tp&&>(__t) = __iter_exchange_move(__u, __t);
            }
        };
    } // namespace __iter_swap

    inline namespace __cpos {
        inline constexpr __iter_swap::__fn iter_swap{};
    }
} // namespace ranges

template <class _Iter1, class _Iter2 = _Iter1>
_LIBCPP_CONCEPT_DECL IndirectlySwappable =
    Readable<_Iter1> && Readable<_Iter2> &&
    requires(_Iter1&& __i1, _Iter2&& __i2) {
        _VSTD::ranges::iter_swap(static_cast<_Iter1&&>(__i1), static_cast<_Iter2&&>(__i2));
        _VSTD::ranges::iter_swap(static_cast<_Iter2&&>(__i2), static_cast<_Iter1&&>(__i1));
        _VSTD::ranges::iter_swap(static_cast<_Iter1&&>(__i1), static_cast<_Iter1&&>(__i1));
        _VSTD::ranges::iter_swap(static_cast<_Iter2&&>(__i2), static_cast<_Iter2&&>(__i2));
    };

template <class _Iter1, class _Iter2, class _Rel,
    class _Proj1 = identity, class _Proj2 = identity>
_LIBCPP_CONCEPT_DECL IndirectlyComparable =
    IndirectRelation<_Rel, projected<_Iter1, _Proj1>, projected<_Iter2, _Proj2>>;

template <class _Iter>
_LIBCPP_CONCEPT_DECL Permutable =
    ForwardIterator<_Iter> &&
    IndirectlyMovableStorable<_Iter, _Iter> &&
    IndirectlySwappable<_Iter, _Iter>;

template <class _Iter1, class _Iter2, class _Out, class _Rel = ranges::less<>,
    class _Proj1 = identity, class _Proj2 = identity>
_LIBCPP_CONCEPT_DECL Mergeable =
    InputIterator<_Iter1> &&
    InputIterator<_Iter2> &&
    WeaklyIncrementable<_Out> &&
    IndirectlyCopyable<_Iter1, _Out> &&
    IndirectlyCopyable<_Iter2, _Out> &&
    IndirectStrictWeakOrder<_Rel, projected<_Iter1, _Proj1>, projected<_Iter2, _Proj2>>;

template <class _Iter, class _Rel = ranges::less<>, class _Proj = identity>
_LIBCPP_CONCEPT_DECL Sortable =
    Permutable<_Iter> && IndirectStrictWeakOrder<_Rel, projected<_Iter, _Proj>>;

template <class _Tp>
requires is_object_v<_Tp>
struct _LIBCPP_TEMPLATE_VIS iterator_traits<_Tp*>
{
    using difference_type   = ptrdiff_t;
    using value_type        = remove_cv_t<_Tp>;
    using pointer           = _Tp*;
    using reference         = _Tp&;
    using iterator_category = random_access_iterator_tag;
    using iterator_concept  = contiguous_iterator_tag;
};

template <class _Iter>
_LIBCPP_CONCEPT_DECL _Cpp17Iterator = Copyable<_Iter> && requires(_Iter __i) {
    { *__i } -> __can_reference&&;
    { ++__i } -> Same<_Iter>&;
    { *__i++ } -> __can_reference&&;
};

template <class _Iter>
_LIBCPP_CONCEPT_DECL _Cpp17InputIterator =
    _Cpp17Iterator<_Iter> && EqualityComparable<_Iter> &&
    __has_member_difference_type<incrementable_traits<_Iter>> &&
    __has_member_value_type<readable_traits<_Iter>> &&
    requires(_Iter __i) {
        typename common_reference_t<iter_reference_t<_Iter>&&,
            typename readable_traits<_Iter>::value_type&>;
        typename common_reference_t<decltype(*__i++)&&,
            typename readable_traits<_Iter>::value_type&>;
        requires SignedIntegral<typename incrementable_traits<_Iter>::difference_type>;
    };

template <class _Iter>
_LIBCPP_CONCEPT_DECL _Cpp17ForwardIterator =
    _Cpp17InputIterator<_Iter> && Constructible<_Iter> &&
    Same<remove_cvref_t<iter_reference_t<_Iter>>,
        typename readable_traits<_Iter>::value_type> &&
    requires(_Iter __i) {
        { __i++ } -> const _Iter&;
        requires Same<iter_reference_t<_Iter>, decltype(*__i++)>;
    };

template <class _Iter>
_LIBCPP_CONCEPT_DECL _Cpp17BidirectionalIterator =
    _Cpp17ForwardIterator<_Iter> && requires(_Iter __i) {
        { --__i } -> Same<_Iter>&;
        { __i-- } -> const _Iter&;
        requires Same<iter_reference_t<_Iter>, decltype(*__i--)>;
    };

template <class _Iter>
_LIBCPP_CONCEPT_DECL _Cpp17RandomAccessIterator =
    _Cpp17BidirectionalIterator<_Iter> && StrictTotallyOrdered<_Iter> &&
    requires(_Iter __i, typename incrementable_traits<_Iter>::difference_type __n) {
        { __i += __n } -> Same<_Iter>&;
        { __i -= __n } -> Same<_Iter>&;
        requires Same<_Iter, decltype(__i + __n)>;
        requires Same<_Iter, decltype(__n + __i)>;
        requires Same<_Iter, decltype(__i - __n)>;
        requires Same<decltype(__n), decltype(__i - __i)>;
        { __i[__n] } -> iter_reference_t<_Iter>;
    };

template <class _Iter>
_LIBCPP_CONCEPT_DECL __has_iter_types =
    __has_member_difference_type<_Iter> &&
    __has_member_value_type<_Iter> &&
    __has_member_reference<_Iter> &&
    __has_member_category<_Iter>;

template <bool>
struct _LIBCPP_TEMPLATE_VIS __old_iter_traits_pointer
{
    template <class> using __apply = void;
};

template <>
struct _LIBCPP_TEMPLATE_VIS __old_iter_traits_pointer<true>
{
    template <class _Iter> using __apply = typename _Iter::pointer;
};

template <__has_iter_types _Iter>
struct _LIBCPP_TEMPLATE_VIS iterator_traits<_Iter>
{
    using difference_type   = typename _Iter::difference_type;
    using value_type        = typename _Iter::value_type;
    using pointer           = __apply<__old_iter_traits_pointer<__has_member_pointer<_Iter>>, _Iter>;
    using reference         = typename _Iter::reference;
    using iterator_category = typename _Iter::iterator_category;

    using __is_not_specialized = iterator_traits<_Iter>;
};

template <int>
struct _LIBCPP_TEMPLATE_VIS __iter_traits_pointer
{
    template <class> using __apply = void;
};

template <>
struct _LIBCPP_TEMPLATE_VIS __iter_traits_pointer<1>
{
    template <class _Iter> using __apply = typename _Iter::pointer;
};

template <>
struct _LIBCPP_TEMPLATE_VIS __iter_traits_pointer<2>
{
    template <class _Iter> using __apply = decltype(_VSTD::declval<_Iter&>().operator->());
};

template <class _Tp>
_LIBCPP_CONCEPT_DECL __has_op_arrow =
    requires(_Tp&& __t) { static_cast<_Tp&&>(__t).operator->(); };

template <bool>
struct _LIBCPP_TEMPLATE_VIS __iter_traits_reference
{
    template <class _Iter> using __apply = iter_reference_t<_Iter>;
};

template <>
struct _LIBCPP_TEMPLATE_VIS __iter_traits_reference<true>
{
    template <class _Iter> using __apply = typename _Iter::reference;
};

template <bool>
struct _LIBCPP_TEMPLATE_VIS __iter_traits_category
{
    template <class _Iter> using __apply =
        __select<_Cpp17RandomAccessIterator<_Iter>, random_access_iterator_tag,
        __select<_Cpp17BidirectionalIterator<_Iter>, bidirectional_iterator_tag,
        __select<_Cpp17ForwardIterator<_Iter>, forward_iterator_tag,
        input_iterator_tag>>>;
};

template <>
struct _LIBCPP_TEMPLATE_VIS __iter_traits_category<true>
{
    template <class _Iter> using __apply = typename _Iter::iterator_category;
};

template <class _Iter>
requires !__has_iter_types<_Iter> && _Cpp17InputIterator<_Iter>
struct _LIBCPP_TEMPLATE_VIS iterator_traits<_Iter>
{
    using difference_type = typename incrementable_traits<_Iter>::difference_type;
    using value_type      = typename readable_traits<_Iter>::value_type;
    using pointer         = __apply<__iter_traits_pointer<(__has_member_pointer<_Iter> ? 1 : __has_op_arrow<_Iter&> ? 2 : 0)>, _Iter>;
    using reference       = __apply<__iter_traits_reference<__has_member_reference<_Iter>>, _Iter>;
    using category        = __apply<__iter_traits_category<__has_member_category<_Iter>>, _Iter>;

    using __is_not_specialized = iterator_traits<_Iter>;
};

template <bool>
struct _LIBCPP_TEMPLATE_VIS __iter_traits_difference
{
    template <class> using __apply = void;
};

template <>
struct _LIBCPP_TEMPLATE_VIS __iter_traits_difference<true>
{
    template <class _Iter> using __apply = typename incrementable_traits<_Iter>::difference_type;
};

template <class _Iter>
requires !__has_iter_types<_Iter> && _Cpp17Iterator<_Iter>
struct _LIBCPP_TEMPLATE_VIS iterator_traits<_Iter>
{
    using difference_type   = __apply<__iter_traits_difference<__has_member_difference_type<incrementable_traits<_Iter>>>, _Iter>;
    using value_type        = void;
    using pointer           = void;
    using reference         = void;
    using iterator_category = output_iterator_tag;

    using __is_not_specialized = iterator_traits<_Iter>;
};

namespace ranges
{
    namespace __begin
    {
        template <class _Tp>
        void begin(_Tp&&) = delete;
        template <class _Tp>
        void begin(initializer_list<_Tp>&&) = delete;

        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __has_member =
            is_lvalue_reference_v<_Tp> && requires(_Tp& __t) {
                __t.begin();
                { _VSTD::__test_convert(__t.begin()) } -> Iterator;
            };

        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __has_adl = requires(_Tp&& __t) {
            begin(static_cast<_Tp&&>(__t));
            { _VSTD::__test_convert(begin(static_cast<_Tp&&>(__t))) } -> Iterator;
        };

        struct __fn
        {
            template <class _Tp, size_t _Count>
            constexpr _Tp* operator()(_Tp (&__x)[_Count]) const _NOEXCEPT
            {
                return __x + 0;
            }

            template <class _Tp>
            requires __has_member<_Tp&>
            constexpr auto operator()(_Tp& __t) const
                _NOEXCEPT_(noexcept(_VSTD::__test_convert(__t.begin())))
            {
                return __t.begin();
            }

            template <class _Tp>
            requires !__has_member<_Tp> && __has_adl<_Tp>
            constexpr auto operator()(_Tp&& __t) const
                _NOEXCEPT_(noexcept(_VSTD::__test_convert(begin(static_cast<_Tp&&>(__t)))))
            {
                return begin(static_cast<_Tp&&>(__t));
            }
        };
    }

    inline namespace __cpos {
        inline constexpr __begin::__fn begin{};
    }

    namespace __end
    {
        template <class _Tp>
        void end(_Tp&&) = delete;
        template <class _Tp>
        void end(initializer_list<_Tp>&&) = delete;

        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __has_member =
            is_lvalue_reference_v<_Tp> && requires(_Tp& __t) {
                __t.end();
                begin(__t);
                { _VSTD::__test_convert(__t.end()) } -> Sentinel<decltype(begin(__t))>;
            };

        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __has_adl = requires(_Tp&& __t) {
            end(static_cast<_Tp&&>(__t));
            begin(static_cast<_Tp&&>(__t));
            { _VSTD::__test_convert(end(static_cast<_Tp&&>(__t))) } ->
                Sentinel<decltype(begin(static_cast<_Tp&&>(__t)))>;
        };

        struct __fn
        {
            template <class _Tp, size_t _Count>
            constexpr _Tp* operator()(_Tp (&__x)[_Count]) const _NOEXCEPT
            {
                return __x + _Count;
            }

            template <class _Tp>
            requires __has_member<_Tp&>
            constexpr auto operator()(_Tp& __t) const
                _NOEXCEPT_(noexcept(_VSTD::__test_convert(__t.end())))
            {
                return __t.end();
            }

            template <class _Tp>
            requires !__has_member<_Tp> && __has_adl<_Tp>
            constexpr auto operator()(_Tp&& __t) const
                _NOEXCEPT_(noexcept(_VSTD::__test_convert(end(static_cast<_Tp&&>(__t)))))
            {
                return end(static_cast<_Tp&&>(__t));
            }
        };
    }

    inline namespace __cpos {
        inline constexpr __end::__fn end{};
    }

    template <class _Tp>
    struct __const_thru_ref_
    {
        using type = const _Tp;
    };
    template <class _Tp>
    struct __const_thru_ref_<_Tp&>
    {
        using type = const _Tp&;
    };
    template <class _Tp>
    struct __const_thru_ref_<_Tp&&>
    {
        using type = const _Tp&&;
    };
    template <class _Tp>
    using __const_thru_ref = typename __const_thru_ref_<_Tp>::type;

    struct __cbegin_fn
    {
        template <class _Tp>
        requires requires(__const_thru_ref<_Tp>&& __t) {
            begin(static_cast<__const_thru_ref<_Tp>&&>(__t));
        }
        constexpr auto operator()(_Tp&& __t) const
            _NOEXCEPT_(noexcept(begin(static_cast<__const_thru_ref<_Tp>&&>(__t))))
        {
            return begin(static_cast<__const_thru_ref<_Tp>&&>(__t));
        }
    };

    inline namespace __cpos {
        inline constexpr __cbegin_fn cbegin{};
    }

    struct __cend_fn
    {
        template <class _Tp>
        requires requires(__const_thru_ref<_Tp>&& __t) {
            end(static_cast<__const_thru_ref<_Tp>&&>(__t));
        }
        constexpr auto operator()(_Tp&& __t) const
            _NOEXCEPT_(noexcept(end(static_cast<__const_thru_ref<_Tp>&&>(__t))))
        {
            return end(static_cast<__const_thru_ref<_Tp>&&>(__t));
        }
    };

    inline namespace __cpos {
        inline constexpr __cend_fn cend{};
    }

    namespace __rbegin
    {
        template <class _Tp> void rbegin(_Tp&&) = delete;

        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __has_member =
            is_lvalue_reference_v<_Tp> && requires(_Tp& __t) {
                __t.rbegin();
                { _VSTD::__test_convert(__t.rbegin()) } -> Iterator;
            };

        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __has_adl = requires(_Tp&& __t) {
            rbegin(static_cast<_Tp&&>(__t));
            { _VSTD::__test_convert(rbegin(static_cast<_Tp&&>(__t))) } -> Iterator;
        };

        struct __fn
        {
            template <class _Tp>
            requires __has_member<_Tp&>
            constexpr auto operator()(_Tp& __t) const
                _NOEXCEPT_(noexcept(_VSTD::__test_convert(__t.rbegin())))
            {
                return __t.rbegin();
            }

            template <class _Tp>
            requires !__has_member<_Tp> && __has_adl<_Tp>
            constexpr auto operator()(_Tp& __t) const
                _NOEXCEPT_(noexcept(_VSTD::__test_convert(rbegin(static_cast<_Tp&&>(__t)))))
            {
                return rbegin(static_cast<_Tp&&>(__t));
            }

            template <class _Tp>
            requires !__has_member<_Tp> && !__has_adl<_Tp> &&
                requires(_Tp&& __t) {
                    { begin(static_cast<_Tp&&>(__t)) } -> BidirectionalIterator;
                    { end(static_cast<_Tp&&>(__t)) } ->
                        Same<decltype(begin(static_cast<_Tp&&>(__t)))>;
                }
            constexpr auto operator()(_Tp&& __t) const
                _NOEXCEPT_(noexcept(_VSTD::make_reverse_iterator(end(static_cast<_Tp&&>(__t)))))
            {
                return _VSTD::make_reverse_iterator(end(static_cast<_Tp&&>(__t)));
            }
        };
    }

    inline namespace __cpos {
        inline constexpr __rbegin::__fn rbegin{};
    }

    namespace __rend
    {
        template <class _Tp> void rend(_Tp&&) = delete;

        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __has_member =
            is_lvalue_reference_v<_Tp> && requires(_Tp& __t) {
                __t.rend();
                rbegin(__t);
                { _VSTD::__test_convert(__t.rend()) } ->
                    Sentinel<decltype(rbegin(__t))>;
            };

        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __has_adl = requires(_Tp&& __t) {
            rend(static_cast<_Tp&&>(__t));
            rbegin(static_cast<_Tp&&>(__t));
            { _VSTD::__test_convert(rend(static_cast<_Tp&&>(__t))) } ->
                Sentinel<decltype(rbegin(static_cast<_Tp&&>(__t)))>;
        };

        struct __fn
        {
            template <class _Tp>
            requires __has_member<_Tp&>
            constexpr auto operator()(_Tp& __t) const
                _NOEXCEPT_(noexcept(_VSTD::__test_convert(__t.rend())))
            {
                return __t.rend();
            }

            template <class _Tp>
            requires !__has_member<_Tp> && __has_adl<_Tp>
            constexpr auto operator()(_Tp& __t) const
                _NOEXCEPT_(noexcept(_VSTD::__test_convert(rend(static_cast<_Tp&&>(__t)))))
            {
                return rend(static_cast<_Tp&&>(__t));
            }

            template <class _Tp>
            requires !__has_member<_Tp> && !__has_adl<_Tp> &&
                requires(_Tp&& __t) {
                    { begin(static_cast<_Tp&&>(__t)) } -> BidirectionalIterator;
                    { end(static_cast<_Tp&&>(__t)) } ->
                        Same<decltype(begin(static_cast<_Tp&&>(__t)))>;
                }
            constexpr auto operator()(_Tp&& __t) const
                _NOEXCEPT_(noexcept(_VSTD::make_reverse_iterator(begin(static_cast<_Tp&&>(__t)))))
            {
                return _VSTD::make_reverse_iterator(begin(static_cast<_Tp&&>(__t)));
            }
        };
    }

    inline namespace __cpos {
        inline constexpr __rend::__fn rend{};
    }

    struct __crbegin_fn
    {
        template <class _Tp>
        requires requires(__const_thru_ref<_Tp>&& __t) {
            rbegin(static_cast<__const_thru_ref<_Tp>&&>(__t));
        }
        constexpr auto operator()(_Tp&& __t) const
            _NOEXCEPT_(noexcept(rbegin(static_cast<__const_thru_ref<_Tp>&&>(__t))))
        {
            return rbegin(static_cast<__const_thru_ref<_Tp>&&>(__t));
        }
    };

    inline namespace __cpos {
        inline constexpr __crbegin_fn crbegin{};
    }

    struct __crend_fn
    {
        template <class _Tp>
        requires requires(__const_thru_ref<_Tp>&& __t) {
            rend(static_cast<__const_thru_ref<_Tp>&&>(__t));
        }
        constexpr auto operator()(_Tp&& __t) const
            _NOEXCEPT_(noexcept(rend(static_cast<__const_thru_ref<_Tp>&&>(__t))))
        {
            return rend(static_cast<__const_thru_ref<_Tp>&&>(__t));
        }
    };

    inline namespace __cpos {
        inline constexpr __crend_fn crend{};
    }

    template <class _Tp>
    inline constexpr bool disable_sized_range = false;

    namespace __size
    {
        template <class _Tp> void size(_Tp&&) = delete;

        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __has_member = requires(_Tp&& __t) {
            requires !disable_sized_range<remove_cvref_t<_Tp>>;
            static_cast<_Tp&&>(__t).size();
            { _VSTD::__test_convert(static_cast<_Tp&&>(__t).size()) } -> Integral;
        };

        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __has_adl = requires(_Tp&& __t) {
            requires !disable_sized_range<remove_cvref_t<_Tp>>;
            size(static_cast<_Tp&&>(__t));
            { _VSTD::__test_convert(size(static_cast<_Tp&&>(__t))) } -> Integral;
        };

        struct __fn
        {
            template <class _Tp, size_t _Count>
            constexpr size_t operator()(_Tp (&)[_Count]) const _NOEXCEPT
            {
                return _Count;
            }

            template <class _Tp>
            requires __has_member<_Tp>
            constexpr auto operator()(_Tp&& __t) const
                _NOEXCEPT_(noexcept(_VSTD::__test_convert(static_cast<_Tp&&>(__t).size())))
            {
                return static_cast<_Tp&&>(__t).size();
            }

            template <class _Tp>
            requires !__has_member<_Tp> && __has_adl<_Tp>
            constexpr auto operator()(_Tp&& __t) const
                _NOEXCEPT_(noexcept(_VSTD::__test_convert(size(static_cast<_Tp&&>(__t)))))
            {
                return size(static_cast<_Tp&&>(__t));
            }

            template <class _Tp>
            requires !__has_member<_Tp> && __has_adl<_Tp> && requires(_Tp&& __t) {
                begin(__t); // FIXME: specify this lvalue treatment
                end(__t); // FIXME: specify this lvalue treatment
                requires ForwardIterator<decltype(begin(__t))>;
                requires SizedSentinel<decltype(end(__t)), decltype(begin(__t))>;
            }
            constexpr auto operator()(_Tp&& __t) const
                _NOEXCEPT_(noexcept(end(__t) - begin(__t)))
            {
                return end(__t) - begin(__t);
            }
        };
    }

    inline namespace __cpos {
        inline constexpr __size::__fn size{};
    }

    namespace __empty
    {
        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __has_member = requires(_Tp&& __t) {
            static_cast<_Tp&&>(__t).empty();
            bool(static_cast<_Tp&&>(__t).empty());
        };

        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __has_size = requires(_Tp&& __t) {
            size(static_cast<_Tp&&>(__t));
        };

        struct __fn
        {
            template <class _Tp>
            requires __has_member<_Tp>
            constexpr bool operator()(_Tp&& __t) const
                _NOEXCEPT_(noexcept(bool(static_cast<_Tp&&>(__t).empty())))
            {
                return bool(static_cast<_Tp&&>(__t).empty());
            }

            template <class _Tp>
            requires !__has_member<_Tp> && __has_size<_Tp>
            constexpr bool operator()(_Tp&& __t) const
                _NOEXCEPT_(noexcept(size(static_cast<_Tp&&>(__t))))
            {
                return !size(static_cast<_Tp&&>(__t));
            }

            template <class _Tp>
            requires !__has_member<_Tp> && !__has_size<_Tp> && requires(_Tp&& __t) {
                begin(__t); // FIXME: specify this lvalue treatment
                end(__t); // FIXME: specify this lvalue treatment
                requires ForwardIterator<decltype(begin(__t))>;
            }
            constexpr bool operator()(_Tp&& __t) const
                _NOEXCEPT_(noexcept(bool(begin(__t) == end(__t))))
            {
                return bool(begin(__t) == end(__t));
            }
        };
    }

    inline namespace __cpos {
        inline constexpr __empty::__fn empty{};
    }

    namespace __data
    {
        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __is_object_pointer =
            is_pointer_v<_Tp> && is_object_v<remove_pointer_t<_Tp>>;

        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __has_member =
            is_lvalue_reference_v<_Tp> && requires(_Tp& __t) {
                __t.data();
                _VSTD::__test_convert(__t.data()) -> __is_object_pointer;
            };

        template <class _Tp>
        _LIBCPP_CONCEPT_DECL __has_pointer_begin = requires(_Tp&& __t) {
            { begin(static_cast<_Tp&&>(__t)) } -> __is_object_pointer;
        };

        template <class _Tp>
        const _Tp& __clvalue(const _Tp&) _NOEXCEPT;

        struct __fn
        {
            template <class _Tp>
            requires __has_member<_Tp&>
            constexpr auto operator()(_Tp& __t) const
                _NOEXCEPT_(noexcept(__t.data()))
            {
                return __t.data();
            }

            template <class _Tp>
            requires !__has_member<_Tp> && __has_pointer_begin<_Tp>
            constexpr auto operator()(_Tp&& __t) const
                _NOEXCEPT_(noexcept(begin(static_cast<_Tp&&>(__t))))
            {
                return begin(static_cast<_Tp&&>(__t));
            }

            template <class _Tp>
            requires !__has_member<_Tp> && !__has_pointer_begin<_Tp> &&
                requires(_Tp&& __t) {
                    begin(__t); // FIXME: specify this lvalue treatment
                    end(__t); // FIXME: specify this lvalue treatment
                    requires ContiguousIterator<decltype(begin(__t))>;
                }
            constexpr auto operator()(_Tp&& __t) const
                _NOEXCEPT_(noexcept(_VSTD::ranges::__data::__clvalue(begin(__t)) == end(__t)
                    ? nullptr : _VSTD::addressof(*_VSTD::ranges::__data::__clvalue(begin(__t)))))
            {
                const auto __i = begin(__t);
                return __i == end(__t) ? nullptr : _VSTD::addressof(*__i);
            }
        };
    }

    inline namespace __cpos {
        inline constexpr __data::__fn data{};
    }

    struct __cdata_fn
    {
        template <class _Tp>
        requires requires(__const_thru_ref<_Tp>&& __t) {
            data(static_cast<__const_thru_ref<_Tp>&&>(__t));
        }
        constexpr auto operator()(_Tp&& __t) const
            _NOEXCEPT_(noexcept(data(static_cast<__const_thru_ref<_Tp>&&>(__t))))
        {
            return data(static_cast<__const_thru_ref<_Tp>&&>(__t));
        }
    };

    inline namespace __cpos {
        inline constexpr __cdata_fn cdata{};
    }

    struct __advance_fn
    {
        template <Iterator _Iter>
        constexpr void operator()(_Iter& __i, iter_difference_t<_Iter> __n) const
        {
            if constexpr (RandomAccessIterator<_Iter>)
                __i += __n;
            else {
                for (; __n > 0; --__n)
                    ++__i;
            }
        }

        template <Iterator _Iter, Sentinel<_Iter> _Sent>
        constexpr void operator()(_Iter& __i, _Sent __s) const
        {
            if constexpr (Assignable<_Iter&, _Sent>)
                __i = _VSTD::move(__s);
            else if constexpr (SizedSentinel<_Sent, _Iter>)
                (*this)(__i, __s - __i);
            else {
                while (__i != __s)
                    ++__i;
            }
        }

        template <Iterator _Iter, Sentinel<_Iter> _Sent>
        constexpr iter_difference_t<_Iter> operator()(
            _Iter& __i, iter_difference_t<_Iter> __n, _Sent __s) const
        {
            if constexpr (SizedSentinel<_Sent, _Iter>) {
                const iter_difference_t<_Iter> __d = __s - __i;
                if ((__n < 0 && __n < __d) || (__n > 0 && __n > __d)) {
                    (*this)(__i, __s);
                    return __n - __d;
                }

                (*this)(__i, __d);
                return 0;
            } else {
                if constexpr (BidirectionalIterator<_Iter>) {
                    for (; __n < 0 && __i != __s; ++__n)
                        --__i;
                }

                for (; __n > 0 && __i != __s; --__n)
                    ++__i;

                return __n;
            }
        }
    };

    template <class _Rng>
    _LIBCPP_CONCEPT_DECL __range_impl = requires(_Rng&& __r) {
        begin(static_cast<_Rng&&>(__r));
        end(static_cast<_Rng&&>(__r));
    };

    template <class _Rng>
    _LIBCPP_CONCEPT_DECL Range = __range_impl<_Rng&>;

    template <class _Rng>
    _LIBCPP_CONCEPT_DECL __forwarding_range = Range<_Rng> && __range_impl<_Rng>;

    template <class _Rng>
    using iterator_t = decltype(begin(_VSTD::declval<_Rng&>()));

    template <class _Rng>
    using sentinel_t = decltype(end(_VSTD::declval<_Rng&>()));

    template <class _Rng>
    _LIBCPP_CONCEPT_DECL SizedRange =
        Range<_Rng> && !disable_sized_range<remove_cvref_t<_Rng>> &&
        requires(_Rng& __r) {
            { size(__r) } -> ConvertibleTo<iter_difference_t<iterator_t<_Rng>>>;
        };

    struct __distance_fn
    {
        template <Iterator _Iter, Sentinel<_Iter> _Sent>
        constexpr iter_difference_t<_Iter> operator()(_Iter __i, _Sent __s) const
        {
            if constexpr (SizedSentinel<_Sent, _Iter>)
                return __s - __i;
            else {
                iter_difference_t<_Iter> __n = 0;
                for (; __i != __s; ++__i)
                    ++__n;
                return __n;
            }
        }

        template <Range _Rng>
        constexpr iter_difference_t<iterator_t<_Rng>> operator()(_Rng&& __r) const
        {
            if constexpr (SizedRange<_Rng>)
                return static_cast<iter_difference_t<iterator_t<_Rng>>>(size(__r));
            else
                return (*this)(begin(__r), end(__r));
        }
    };

    inline namespace __cpos {
        constexpr __advance_fn advance{};
        constexpr __distance_fn distance{};
    }

    struct __next_fn
    {
        template <Iterator _Iter>
        constexpr _Iter operator()(_Iter __i) const
        {
            ++__i;
            return __i;
        }

        template <Iterator _Iter>
        constexpr _Iter operator()(_Iter __i, iter_difference_t<_Iter> __n) const
        {
            advance(__i, __n);
            return __i;
        }

        template <Iterator _Iter, Sentinel<_Iter> _Sent>
        constexpr _Iter operator()(_Iter __i, _Sent __s) const
        {
            advance(__i, _VSTD::move(__s));
            return __i;
        }

        template <Iterator _Iter, Sentinel<_Iter> _Sent>
        constexpr _Iter operator()(_Iter __i, iter_difference_t<_Iter> __n, _Sent __s) const
        {
            advance(__i, __n, _VSTD::move(__s));
            return __i;
        }
    };

    struct __prev_fn
    {
        template <BidirectionalIterator _Iter>
        constexpr _Iter operator()(_Iter __i) const
        {
            --__i;
            return __i;
        }

        template <BidirectionalIterator _Iter>
        constexpr _Iter operator()(_Iter __i, iter_difference_t<_Iter> __n) const
        {
            advance(__i, -__n);
            return __i;
        }

        template <BidirectionalIterator _Iter>
        constexpr _Iter operator()(_Iter __i, iter_difference_t<_Iter> __n, _Iter __s) const
        {
            advance(__i, -__n, _VSTD::move(__s));
            return __i;
        }
    };

    inline namespace __cpos {
        constexpr __next_fn next{};
        constexpr __prev_fn prev{};
    }
} // namespace ranges

#else // ^^^ Ranges / !Ranges vvv

template <class _Iter, bool> struct __iterator_traits_impl {};

template <class _Iter>
struct __iterator_traits_impl<_Iter, true>
{
    typedef typename _Iter::difference_type   difference_type;
    typedef typename _Iter::value_type        value_type;
    typedef typename _Iter::pointer           pointer;
    typedef typename _Iter::reference         reference;
    typedef typename _Iter::iterator_category iterator_category;
};

template <class _Iter, bool> struct __iterator_traits {};

template <class _Iter>
struct __iterator_traits<_Iter, true>
    :  __iterator_traits_impl
      <
        _Iter,
        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
      >
{};


template <class _Tp>
struct __has_iterator_typedefs
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename std::__void_t<typename _Up::iterator_category>::type* = 0,
    										typename std::__void_t<typename _Up::difference_type>::type* = 0,
    										typename std::__void_t<typename _Up::value_type>::type* = 0,
    										typename std::__void_t<typename _Up::reference>::type* = 0,
    										typename std::__void_t<typename _Up::pointer>::type* = 0
    										);
public:
    static const bool value = sizeof(__test<_Tp>(0,0,0,0,0)) == 1;
};

template <class _Iter>
struct _LIBCPP_TEMPLATE_VIS iterator_traits
    : __iterator_traits<_Iter, __has_iterator_typedefs<_Iter>::value> {};

template <class _Tp>
struct _LIBCPP_TEMPLATE_VIS iterator_traits<_Tp*>
{
    typedef ptrdiff_t difference_type;
    typedef typename remove_cv<_Tp>::type value_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef random_access_iterator_tag iterator_category;
};
#endif // _LIBCPP_HAS_RANGES

template <class _Tp>
struct __has_iterator_category
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::iterator_category* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to
    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>
{};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};

template <class _Tp>
struct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};

template <class _Tp>
struct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};

template <class _Tp>
struct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};

template <class _Tp>
struct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};

template <class _Tp>
struct __is_exactly_input_iterator
    : public integral_constant<bool,
         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value &&
        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};

template <class _InputIter>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
void __advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)
{
    for (; __n > 0; --__n)
        ++__i;
}

template <class _BiDirIter>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
void __advance(_BiDirIter& __i,
             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)
{
    if (__n >= 0)
        for (; __n > 0; --__n)
            ++__i;
    else
        for (; __n < 0; ++__n)
            --__i;
}

template <class _RandIter>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
void __advance(_RandIter& __i,
             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)
{
   __i += __n;
}

template <class _InputIter>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
void advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n)
{
    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
{
    typename iterator_traits<_InputIter>::difference_type __r(0);
    for (; __first != __last; ++__first)
        ++__r;
    return __r;
}

template <class _RandIter>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
{
    return __last - __first;
}

template <class _InputIter>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last)
{
    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
typename enable_if
<
    __is_input_iterator<_InputIter>::value,
    _InputIter
>::type
next(_InputIter __x,
     typename iterator_traits<_InputIter>::difference_type __n = 1)
{
    _VSTD::advance(__x, __n);
    return __x;
}

template <class _BidirectionalIter>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
typename enable_if
<
    __is_bidirectional_iterator<_BidirectionalIter>::value,
    _BidirectionalIter
>::type
prev(_BidirectionalIter __x,
     typename iterator_traits<_BidirectionalIter>::difference_type __n = 1)
{
    _VSTD::advance(__x, -__n);
    return __x;
}


template <class _Tp, class = void>
struct __is_stashing_iterator : false_type {};

template <class _Tp>
struct __is_stashing_iterator<_Tp, typename __void_t<typename _Tp::__stashing_iterator_tag>::type>
  : true_type {};

#ifdef _LIBCPP_HAS_RANGES
template <class _Cat>
using __not_contiguous_cat = __select<
    DerivedFrom<_Cat, random_access_iterator_tag>,
    random_access_iterator_tag, _Cat>;

template <class _Iter>
class _LIBCPP_TEMPLATE_VIS reverse_iterator
    : public iterator<__not_contiguous_cat<typename iterator_traits<_Iter>::iterator_category>,
                      iter_value_t<_Iter>,
                      iter_difference_t<_Iter>,
                      typename iterator_traits<_Iter>::pointer,
                      iter_reference_t<_Iter>>
#else // ^^^ Ranges / !Ranges vvv
template <class _Iter>
class _LIBCPP_TEMPLATE_VIS reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>
#endif // _LIBCPP_HAS_RANGES
{
private:
    /*mutable*/ _Iter __t;  // no longer used as of LWG #2360, not removed due to ABI break

    static_assert(!__is_stashing_iterator<_Iter>::value,
      "The specified iterator type cannot be used with reverse_iterator; "
      "Using stashing iterators with reverse_iterator causes undefined behavior");

protected:
    _Iter current;
public:
    typedef _Iter                                            iterator_type;
#ifdef _LIBCPP_HAS_RANGES
    using typename reverse_iterator::iterator::difference_type;
    using typename reverse_iterator::iterator::reference;
#else
    typedef typename iterator_traits<_Iter>::difference_type difference_type;
    typedef typename iterator_traits<_Iter>::reference       reference;
#endif
    typedef typename iterator_traits<_Iter>::pointer         pointer;

    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    reverse_iterator() : __t(), current() {}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}
    template <class _Up>
        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
        reverse_iterator(const reverse_iterator<_Up>& __u) : __t(__u.base()), current(__u.base()) {}
    template <class _Up>
        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
        reverse_iterator& operator=(const reverse_iterator<_Up>& __u)
            { __t = current = __u.base(); return *this; }
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    _Iter base() const {return current;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    reference operator*() const {_Iter __tmp = current; return *--__tmp;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    reverse_iterator& operator++() {--current; return *this;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    reverse_iterator  operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    reverse_iterator& operator--() {++current; return *this;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    reverse_iterator  operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    reverse_iterator  operator+ (difference_type __n) const {return reverse_iterator(current - __n);}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    reverse_iterator  operator- (difference_type __n) const {return reverse_iterator(current + __n);}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    reference         operator[](difference_type __n) const {return *(*this + __n);}

#ifdef _LIBCPP_HAS_RANGES
    using iterator_concept = __select<RandomAccessIterator<_Iter>,
        random_access_iterator_tag, bidirectional_iterator_tag>;

    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    pointer operator->() const requires is_pointer_v<_Iter> || __has_op_arrow<const _Iter&>
    {
        auto __tmp = current; --__tmp;
        if constexpr (is_pointer_v<_Iter>) {
            return __tmp;
        } else {
            return __tmp.operator->();
        }
    }

    friend constexpr iter_rvalue_reference_t<_Iter> iter_move(const reverse_iterator& __i)
        _NOEXCEPT_(noexcept(_VSTD::ranges::iter_move(__i.current)) && noexcept(--__i.current) &&
            is_nothrow_copy_constructible_v<_Iter>)
    { auto __tmp = __i.current; --__tmp; return _VSTD::ranges::iter_move(__tmp); }

    friend constexpr void iter_swap(const reverse_iterator& __x, const reverse_iterator& __y)
        _NOEXCEPT_(noexcept(_VSTD::ranges::iter_swap(__x.current, __y.current)) &&
            noexcept(--__x.current) && is_nothrow_copy_constructible_v<_Iter>)
    {
        auto __xtmp = __x.current; --__xtmp;
        auto __ytmp = __y.current; --__ytmp;
        _VSTD::ranges::iter_swap(__xtmp, __ytmp);
    }
#else // ^^^ Ranges / !Ranges vvv
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    pointer  operator->() const {return _VSTD::addressof(operator*());}
#endif // _LIBCPP_HAS_RANGES
};

#ifdef _LIBCPP_HAS_RANGES
template <class _Iter1, class _Iter2>
requires !SizedSentinel<_Iter1, _Iter2>
inline constexpr bool disable_sized_sentinel<
    reverse_iterator<_Iter1>, reverse_iterator<_Iter2>> = true;
#endif

template <class _Iter1, class _Iter2>
#ifdef _LIBCPP_HAS_RANGES
requires requires(const _Iter1& __x, const _Iter2& __y) { { __x == __y } -> bool; }
#endif
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
#ifdef _LIBCPP_HAS_RANGES
requires requires(const _Iter1& __x, const _Iter2& __y) { { __x > __y } -> bool; }
#endif
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
#ifdef _LIBCPP_HAS_RANGES
requires requires(const _Iter1& __x, const _Iter2& __y) { { __x != __y } -> bool; }
#endif
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
#ifdef _LIBCPP_HAS_RANGES
requires requires(const _Iter1& __x, const _Iter2& __y) { { __x < __y } -> bool; }
#endif
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
#ifdef _LIBCPP_HAS_RANGES
requires requires(const _Iter1& __x, const _Iter2& __y) { { __x <= __y } -> bool; }
#endif
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
#ifdef _LIBCPP_HAS_RANGES
requires requires(const _Iter1& __x, const _Iter2& __y) { { __x >= __y } -> bool; }
#endif
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

#ifndef _LIBCPP_CXX03_LANG
template <class _Iter1, class _Iter2>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
auto
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
-> decltype(__y.base() - __x.base())
{
    return __y.base() - __x.base();
}
#else
template <class _Iter1, class _Iter2>
inline _LIBCPP_INLINE_VISIBILITY
typename reverse_iterator<_Iter1>::difference_type
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __y.base() - __x.base();
}
#endif

template <class _Iter>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
{
    return reverse_iterator<_Iter>(__x.base() - __n);
}

template <class _Container>
class _LIBCPP_TEMPLATE_VIS back_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
#ifdef _LIBCPP_HAS_RANGES
                      ptrdiff_t,
#else
                      void,
#endif // _LIBCPP_HAS_RANGES
                      void,
                      void>
{
protected:
    _Container* container = 0;
public:
    typedef _Container container_type;

#ifdef _LIBCPP_HAS_RANGES
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR back_insert_iterator() = default;
#endif // _LIBCPP_HAS_RANGES
    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}
    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_back(__value_); return *this;}
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_back(_VSTD::move(__value_)); return *this;}
#endif  // _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}
    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}
    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}
};

template <class _Container>
inline _LIBCPP_INLINE_VISIBILITY
back_insert_iterator<_Container>
back_inserter(_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class _LIBCPP_TEMPLATE_VIS front_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
#ifdef _LIBCPP_HAS_RANGES
                      ptrdiff_t,
#else
                      void,
#endif
                      void,
                      void>
{
protected:
    _Container* container = 0;
public:
    typedef _Container container_type;

#ifdef _LIBCPP_HAS_RANGES
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR front_insert_iterator() = default;
#endif //_LIBCPP_HAS_RANGES
    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}
    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_front(__value_); return *this;}
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_front(_VSTD::move(__value_)); return *this;}
#endif  // _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}
    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}
    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}
};

template <class _Container>
inline _LIBCPP_INLINE_VISIBILITY
front_insert_iterator<_Container>
front_inserter(_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class _LIBCPP_TEMPLATE_VIS insert_iterator
    : public iterator<output_iterator_tag,
                      void,
#ifdef _LIBCPP_HAS_RANGES
                      ptrdiff_t,
#else // _LIBCPP_HAS_RANGES
                      void,
#endif // _LIBCPP_HAS_RANGES
                      void,
                      void>
{
private:
#ifdef _LIBCPP_HAS_RANGES
    using _Iter = ranges::iterator_t<_Container>;
protected:
    _Container* container = nullptr;
    _Iter iter{};
#else // _LIBCPP_HAS_RANGES
    typedef typename _Container::iterator _Iter;
protected:
    _Container* container;
    _Iter iter;
#endif // _LIBCPP_HAS_RANGES
public:
    typedef _Container container_type;

#ifdef _LIBCPP_HAS_RANGES
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR insert_iterator() = default;
#endif // _LIBCPP_HAS_RANGES
    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, _Iter __i)
        : container(_VSTD::addressof(__x)), iter(__i) {}
    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)
        {iter = container->insert(iter, __value_); ++iter; return *this;}
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)
        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}
#endif  // _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}
    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}
    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}
};

template <class _Container>
inline _LIBCPP_INLINE_VISIBILITY
insert_iterator<_Container>
#ifdef _LIBCPP_HAS_RANGES
inserter(_Container& __x, ranges::iterator_t<_Container> __i)
#else // _LIBCPP_HAS_RANGES
inserter(_Container& __x, typename _Container::iterator __i)
#endif // _LIBCPP_HAS_RANGES
{
    return insert_iterator<_Container>(__x, __i);
}

#ifdef _LIBCPP_HAS_RANGES
class default_sentinel {};
#endif // _LIBCPP_HAS_RANGES

template <class _Tp, class _CharT = char,
          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class _LIBCPP_TEMPLATE_VIS istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    istream_type* __in_stream_;
    _Tp __value_;
public:
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istream_iterator() : __in_stream_(0), __value_() {}
    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(_VSTD::addressof(__s))
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
        }

    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}
    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return _VSTD::addressof((operator*()));}
    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
            return *this;
        }
    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)
        {istream_iterator __t(*this); ++(*this); return __t;}

    template <class _Up, class _CharU, class _TraitsU, class _DistanceU>
    friend _LIBCPP_INLINE_VISIBILITY
    bool
    operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,
               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);

    template <class _Up, class _CharU, class _TraitsU, class _DistanceU>
    friend _LIBCPP_INLINE_VISIBILITY
    bool
    operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,
               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);

#ifdef _LIBCPP_HAS_RANGES
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istream_iterator(default_sentinel)
        : istream_iterator() {}

    friend bool operator==(const istream_iterator& __x, default_sentinel)
    { return !__x.__in_stream_; }
    friend bool operator==(default_sentinel __y, const istream_iterator& __x)
    { return __x == __y; }
    friend bool operator!=(const istream_iterator& __x, default_sentinel __y)
    { return !(__x == __y); }
    friend bool operator!=(default_sentinel __y, const istream_iterator& __x)
    { return !(__x == __y); }
#endif // _LIBCPP_HAS_RANGES
};

template <class _Tp, class _CharT, class _Traits, class _Distance>
inline _LIBCPP_INLINE_VISIBILITY
bool
operator==(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,
           const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y)
{
    return __x.__in_stream_ == __y.__in_stream_;
}

template <class _Tp, class _CharT, class _Traits, class _Distance>
inline _LIBCPP_INLINE_VISIBILITY
bool
operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,
           const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
class _LIBCPP_TEMPLATE_VIS ostream_iterator
    : public iterator<output_iterator_tag, void,
#ifdef _LIBCPP_HAS_RANGES
    ptrdiff_t,
#else // _LIBCPP_HAS_RANGES
    void,
#endif // _LIBCPP_HAS_RANGES
    void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    ostream_type* __out_stream_;
    const char_type* __delim_;
public:
#ifdef _LIBCPP_HAS_RANGES
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR ostream_iterator() _NOEXCEPT
        : __out_stream_(nullptr), __delim_(nullptr) {}
#endif // _LIBCPP_HAS_RANGES
    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s) _NOEXCEPT
        : __out_stream_(_VSTD::addressof(__s)), __delim_(0) {}
    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter) _NOEXCEPT
        : __out_stream_(_VSTD::addressof(__s)), __delim_(__delimiter) {}
    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)
        {
            *__out_stream_ << __value_;
            if (__delim_)
                *__out_stream_ << __delim_;
            return *this;
        }

    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}
    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}
    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}
};

template <class _CharT, class _Traits>
class _LIBCPP_TEMPLATE_VIS istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*,
                      _CharT>
{
public:
    typedef _CharT                          char_type;
    typedef _Traits                         traits_type;
    typedef typename _Traits::int_type      int_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_istream<_CharT,_Traits>   istream_type;
private:
    mutable streambuf_type* __sbuf_;

    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)
            : __keep_(__c), __sbuf_(__s) {}
        friend class istreambuf_iterator;
    public:
        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}
    };

    _LIBCPP_INLINE_VISIBILITY
    bool __test_for_eof() const
    {
        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
            __sbuf_ = 0;
        return __sbuf_ == 0;
    }
public:
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}
    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT
        : __sbuf_(__s.rdbuf()) {}
    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT
        : __sbuf_(__s) {}
    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT
        : __sbuf_(__p.__sbuf_) {}

    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const
        {return static_cast<char_type>(__sbuf_->sgetc());}
    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()
        {
            __sbuf_->sbumpc();
            return *this;
        }
    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)
        {
            return __proxy(__sbuf_->sbumpc(), __sbuf_);
        }

    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const
        {return __test_for_eof() == __b.__test_for_eof();}

#ifdef _LIBCPP_HAS_RANGES
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator(default_sentinel) _NOEXCEPT
        : istreambuf_iterator() {}

    friend bool operator==(const istreambuf_iterator& __x, default_sentinel __y)
    { return __x.equal(__y); }
    friend bool operator==(default_sentinel __y, const istreambuf_iterator& __x)
    { return __x == __y; }
    friend bool operator!=(const istreambuf_iterator& __x, default_sentinel __y)
    { return !(__x == __y); }
    friend bool operator!=(default_sentinel __y, const istreambuf_iterator& __x)
    { return !(__x == __y); }
#endif // _LIBCPP_HAS_RANGES
};

template <class _CharT, class _Traits>
inline _LIBCPP_INLINE_VISIBILITY
bool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return __a.equal(__b);}

template <class _CharT, class _Traits>
inline _LIBCPP_INLINE_VISIBILITY
bool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return !__a.equal(__b);}

template <class _CharT, class _Traits>
class _LIBCPP_TEMPLATE_VIS ostreambuf_iterator
    : public iterator<output_iterator_tag, void,
#ifdef _LIBCPP_HAS_RANGES
    ptrdiff_t,
#else // _LIBCPP_HAS_RANGES
    void,
#endif // _LIBCPP_HAS_RANGES
    void, void>
{
public:
    typedef _CharT                          char_type;
    typedef _Traits                         traits_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_ostream<_CharT,_Traits>   ostream_type;
private:
    streambuf_type* __sbuf_;
public:
#ifdef _LIBCPP_HAS_RANGES
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR ostreambuf_iterator() _NOEXCEPT
        : __sbuf_(nullptr) {}
#endif // _LIBCPP_HAS_RANGES
    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT
        : __sbuf_(__s.rdbuf()) {}
    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT
        : __sbuf_(__s) {}
    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)
        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
                __sbuf_ = 0;
            return *this;
        }
    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}
    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}
    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}
    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}

#if !defined(__APPLE__) || \
    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \
    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)

    template <class _Ch, class _Tr>
    friend
    _LIBCPP_HIDDEN
    ostreambuf_iterator<_Ch, _Tr>
    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,
                     ios_base& __iob, _Ch __fl);
#endif
};

#ifdef _LIBCPP_HAS_RANGES
template <Semiregular> class move_sentinel;
#endif

template <class _Iter>
class _LIBCPP_TEMPLATE_VIS move_iterator
{
private:
    _Iter __i;
public:
    typedef _Iter                                            iterator_type;
#ifdef _LIBCPP_HAS_RANGES
    using iterator_category =
        __not_contiguous_cat<typename iterator_traits<_Iter>::iterator_category>;
    using value_type = iter_value_t<iterator_type>;
    using difference_type = iter_difference_t<iterator_type>;
    using reference = iter_rvalue_reference_t<iterator_type>;
    using iterator_concept = input_iterator_tag;
#else
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
#ifndef _LIBCPP_CXX03_LANG
    typedef typename iterator_traits<iterator_type>::reference __reference;
    typedef typename conditional<
            is_reference<__reference>::value,
            typename remove_reference<__reference>::type&&,
            __reference
        >::type reference;
#else
    typedef typename iterator_traits<iterator_type>::reference reference;
#endif
#endif // _LIBCPP_HAS_RANGES
    typedef iterator_type pointer;

    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    move_iterator() : __i() {}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    explicit move_iterator(_Iter __x) : __i(__x) {}
    template <class _Up>
      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
      move_iterator(const move_iterator<_Up>& __u) : __i(__u.base()) {}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 _Iter base() const {return __i;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    pointer  operator->() const { return __i;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    move_iterator& operator++() {++__i; return *this;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    move_iterator& operator--() {--__i; return *this;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    move_iterator  operator--(int) {move_iterator __tmp(*this); --__i; return __tmp;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    move_iterator  operator+ (difference_type __n) const {return move_iterator(__i + __n);}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    move_iterator& operator+=(difference_type __n) {__i += __n; return *this;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    move_iterator  operator- (difference_type __n) const {return move_iterator(__i - __n);}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    move_iterator& operator-=(difference_type __n) {__i -= __n; return *this;}

#ifdef _LIBCPP_HAS_RANGES
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    reference operator*() const { return _VSTD::ranges::iter_move(__i); }
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    decltype(auto) operator++(int)
    {
        if constexpr (ForwardIterator<_Iter>) {
            auto __tmp = *this;
            ++*this;
            return __tmp;
        } else {
            return __i++;
        }
    }
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    reference operator[](difference_type __n) const { return _VSTD::ranges::iter_move(__i + __n); }

    template <Sentinel<_Iter> _Sent>
    friend constexpr bool operator==(
        const move_iterator& __x, const move_sentinel<_Sent>& __y)
    { return __x.__i == __y.__last; }
    template <Sentinel<_Iter> _Sent>
    friend constexpr bool operator==(
        const move_sentinel<_Sent>& __x, const move_iterator& __y)
    { return __y == __x; }
    template <Sentinel<_Iter> _Sent>
    friend constexpr bool operator!=(
        const move_iterator& __x, const move_sentinel<_Sent>& __y)
    { return !(__x == __y); }
    template <Sentinel<_Iter> _Sent>
    friend constexpr bool operator!=(
        const move_sentinel<_Sent>& __x, const move_iterator& __y)
    { return !(__y == __x); }

    template <SizedSentinel<_Iter> _Sent>
    friend constexpr iter_difference_t<_Iter> operator-(
        const move_sentinel<_Sent>& __x, const move_iterator& __y)
    { return __x.__last - __y.__i; }
    template <SizedSentinel<_Iter> _Sent>
    friend constexpr iter_difference_t<_Iter> operator-(
        const move_iterator& __x, const move_sentinel<_Sent>& __y)
    { return __x.__i - __y.__last; }

    friend constexpr reference iter_move(const move_iterator& __x)
        _NOEXCEPT_(noexcept(_VSTD::ranges::iter_move(__x.__i)))
    { return _VSTD::ranges::iter_move(__x.__i); }

    template <IndirectlySwappable<_Iter> _Iter2>
    friend constexpr void iter_swap(const move_iterator& __x, const move_iterator<_Iter2>& __y)
        _NOEXCEPT_(noexcept(_VSTD::ranges::iter_swap(__x.__i, __y.__i)))
    { _VSTD::ranges::iter_swap(__x.__i, __y.__i); }

#else // ^^^ Ranges / !Ranges vvv

    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    reference operator*() const { return static_cast<reference>(*__i); }
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    move_iterator  operator++(int) { move_iterator __tmp(*this); ++__i; return __tmp; }
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
    reference operator[](difference_type __n) const { return static_cast<reference>(__i[__n]); }
#endif // _LIBCPP_HAS_RANGES
};

template <class _Iter1, class _Iter2>
#ifdef _LIBCPP_HAS_RANGES
requires requires(const _Iter1& __x, const _Iter2& __y) { { __x == __y } -> bool; }
#endif
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
bool
operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
#ifdef _LIBCPP_HAS_RANGES
requires requires(const _Iter1& __x, const _Iter2& __y) { { __x != __y } -> bool; }
#endif
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
bool
operator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
#ifdef _LIBCPP_HAS_RANGES
requires requires(const _Iter1& __x, const _Iter2& __y) { { __x < __y } -> bool; }
#endif
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
bool
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
#ifdef _LIBCPP_HAS_RANGES
requires requires(const _Iter1& __x, const _Iter2& __y) { { __x > __y } -> bool; }
#endif
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
bool
operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
#ifdef _LIBCPP_HAS_RANGES
requires requires(const _Iter1& __x, const _Iter2& __y) { { __x <= __y } -> bool; }
#endif
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
bool
operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
#ifdef _LIBCPP_HAS_RANGES
requires requires(const _Iter1& __x, const _Iter2& __y) { { __x >= __y } -> bool; }
#endif
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
bool
operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

#ifndef _LIBCPP_CXX03_LANG
template <class _Iter1, class _Iter2>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
auto
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
-> decltype(__x.base() - __y.base())
{
    return __x.base() - __y.base();
}
#else
template <class _Iter1, class _Iter2>
inline _LIBCPP_INLINE_VISIBILITY
typename move_iterator<_Iter1>::difference_type
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() - __y.base();
}
#endif

template <class _Iter>
#ifdef _LIBCPP_HAS_RANGES
requires requires(const _Iter& __x, iter_difference_t<_Iter> __n) { { __x + __n } -> _Iter; } // FIXME: specify conversion?
#endif
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
{
    return move_iterator<_Iter>(__x.base() + __n);
}

template <class _Iter>
#ifdef _LIBCPP_HAS_RANGES
requires requires(_Iter __x) { move_iterator<_Iter>(__x); }
#endif
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
move_iterator<_Iter>
make_move_iterator(_Iter __i)
{
    return move_iterator<_Iter>(__i);
}

#ifdef _LIBCPP_HAS_RANGES
template <Semiregular _Sent>
class move_sentinel
{
private:
    template <class> friend class move_iterator;
    template <class> friend class move_sentinel;

    _Sent __last{}; // TODO: EBO
public:
    constexpr move_sentinel() = default;
    explicit constexpr move_sentinel(_Sent __s) : __last(_VSTD::move(__s)) {}
    template <ConvertibleTo<_Sent> _Sent2>
    constexpr move_sentinel(const move_sentinel<_Sent2>& __s2)
        : __last(__s2.__last) {}

    template <ConvertibleTo<_Sent> _Sent2>
    constexpr move_sentinel& operator=(const move_sentinel<_Sent2>& __s2)
    { __last = __s2.__last; return *this; }

    _Sent base() const { return __last; }
};

namespace __common_iterator_detail
{
    template <Iterator _Iter, Sentinel<_Iter> _Sent>
    requires !Same<_Iter, _Sent>
    struct __variant_ish1
    {
        union {
            _Iter __iter_;
            _Sent __sent_;
        };

        unsigned char __index_ = 0;

        __variant_ish1() = default;
        __variant_ish1(in_place_index_t<1>)
            : __iter_{}, __index_{1} {}
        template <ConvertibleTo<_Iter> _Tp>
        __variant_ish1(in_place_index_t<1>, _Tp&& __i)
            : __iter_{static_cast<_Tp&&>(__i)}, __index_{1} {}

        template <ConvertibleTo<_Sent> _Tp>
        __variant_ish1(in_place_index_t<2>, _Tp&& __s)
            : __sent_{static_cast<_Tp&&>(__s)}, __index_{2} {}

        ~__variant_ish1() { __reset(); }

        void __reset() _NOEXCEPT
        {
            switch (__index_) {
            case 1: __iter_.~_Iter(); break;
            case 2: __sent_.~_Sent(); break;
            default: break;
            }
            __index_ = 0;
        }
    };

    template <Iterator _Iter, Sentinel<_Iter> _Sent>
    requires !Same<_Iter, _Sent> &&
        is_trivially_destructible_v<_Iter> &&
        is_trivially_destructible_v<_Sent>
    struct __variant_ish1<_Iter, _Sent>
    {
        union {
            _Iter __iter_;
            _Sent __sent_;
        };

        unsigned char __index_ = 0;

        __variant_ish1() = default;
        __variant_ish1(in_place_index_t<1>)
            : __iter_{}, __index_{1} {}
        template <ConvertibleTo<_Iter> _Tp>
        __variant_ish1(in_place_index_t<1>, _Tp&& __i)
            : __iter_{static_cast<_Tp&&>(__i)}, __index_{1} {}

        template <ConvertibleTo<_Sent> _Tp>
        __variant_ish1(in_place_index_t<2>, _Tp&& __s)
            : __sent_{static_cast<_Tp&&>(__s)}, __index_{2} {}

        void __reset() _NOEXCEPT { __index_ = 0; }
    };

    template <Iterator _Iter, Sentinel<_Iter> _Sent>
    requires !Same<_Iter, _Sent>
    struct __variant_ish2 : __variant_ish1<_Iter, _Sent>
    {
        using __variant_ish1<_Iter, _Sent>::__variant_ish1;

        template <ConvertibleTo<_Iter> _Tp>
        void __emplace_iter(_Tp&& __x)
        {   // Pre: this->__index_ == 0
            ::new ((void*)_VSTD::addressof(this->__iter_))
                _Iter(static_cast<_Tp&&>(__x));
            this->__index_ = 1;
        }

        template <ConvertibleTo<_Sent> _Tp>
        void __emplace_sent(_Tp&& __x)
        {   // Pre: this->__index_ == 0
            ::new ((void*)_VSTD::addressof(this->__sent_))
                _Sent(static_cast<_Tp&&>(__x));
            this->__index_ = 2;
        }
    };

    template <Iterator _Iter, Sentinel<_Iter> _Sent>
    requires !Same<_Iter, _Sent>
    struct __variant_ish3_ : __variant_ish1<_Iter, _Sent>
    {
        using __variant_ish1<_Iter, _Sent>::__variant_ish1;
        __variant_ish3_(const __variant_ish3_& __x)
        { __construct_from(__x); }
        __variant_ish3_(__variant_ish3_&& __x)
        { __construct_from(static_cast<__variant_ish3_&&>(__x)); }
        __variant_ish3_& operator=(const __variant_ish3_& __x) = default;
        __variant_ish3_& operator=(__variant_ish3_&& __x) = default;

        template <class _Self>
        void __construct_from(_Self&& __x)
        { // Pre: this->__index_ == 0
            switch (__x.__index_) {
            case 1:
                this->__emplace_iter(static_cast<_Self&&>(__x).__iter_);
                break;
            case 2:
                this->__emplace_sent(static_cast<_Self&&>(__x).__sent_);
                break;
            default:
                break;
            }
        }
    };

    template <Iterator _Iter, Sentinel<_Iter> _Sent>
    requires !Same<_Iter, _Sent>
    using __variant_ish3 = __select<
        is_trivially_copy_constructible_v<_Iter> &&
        is_trivially_copy_constructible_v<_Sent> &&
        is_trivially_move_constructible_v<_Iter> &&
        is_trivially_move_constructible_v<_Sent>,
        __variant_ish2<_Iter, _Sent>, __variant_ish3_<_Iter, _Sent>>;

    template <Iterator _Iter, Sentinel<_Iter> _Sent>
    requires !Same<_Iter, _Sent>
    struct __variant_ish4_ : __variant_ish3<_Iter, _Sent>
    {
        using __variant_ish1<_Iter, _Sent>::__variant_ish1;
        __variant_ish4_(const __variant_ish4_&) = default;
        __variant_ish4_(__variant_ish4_&&) = default;
        __variant_ish4_& operator=(const __variant_ish4_& __x)
        { __assign_from(__x); return *this; }
        __variant_ish4_& operator=(__variant_ish4_&& __x)
        { __assign_from(static_cast<__variant_ish4_&&>(__x)); return *this; }

        template <class _Self>
        void __assign_from(_Self&& __x)
        {
            const auto __i = __x.index();
            if (this->__index_ == __i) {
                switch (__i) {
                case 1:
                    this->__iter_ = static_cast<_Self&&>(__x).__iter_;
                    return;
                case 2:
                    this->__sent_ = static_cast<_Self&&>(__x).__sent_;
                    return;
                default:
                    return;
                }
            }

            this->__reset();

            switch (__i) {
            case 1:
                this->__emplace_iter(static_cast<_Self&&>(__x).__iter_);
                break;
            case 2:
                this->__emplace_sent(static_cast<_Self&&>(__x).__sent_);
                break;
            default:
                break;
            }
        }
    };

    template <Iterator _Iter, Sentinel<_Iter> _Sent>
    requires !Same<_Iter, _Sent>
    using __variant_ish = __select<
        is_trivially_copy_assignable_v<_Iter> &&
        is_trivially_copy_assignable_v<_Sent> &&
        is_trivially_move_assignable_v<_Iter> &&
        is_trivially_move_assignable_v<_Sent>,
        __variant_ish3<_Iter, _Sent>, __variant_ish4_<_Iter, _Sent>>;

    template <class _Tp>
    class __proxy
    {
        _Tp __keep_;
    public:
        template <class _Up>
        requires Constructible<_Tp, _Up>
        __proxy(_Up&& __x)
            : __keep_(static_cast<_Up&&>(__x)) {}

        const _Tp* operator->() const
        { return _VSTD::addressof(__keep_); }
    };
}

template <Iterator _Iter, Sentinel<_Iter> _Sent>
requires !Same<_Iter, _Sent>
class common_iterator
{
public: /* FIXME: private: */
    using _Variant = __common_iterator_detail::__variant_ish<_Iter, _Sent>;
    _Variant __v_{in_place_index<1>};

public:
    using difference_type = iter_difference_t<_Iter>;

    constexpr common_iterator() = default;
    constexpr common_iterator(_Iter __i) : __v_{in_place_index<1>, _VSTD::move(__i)} {}
    constexpr common_iterator(_Sent __s) : __v_{in_place_index<2>, _VSTD::move(__s)} {}
    template <ConvertibleTo<_Iter> _Iter2, ConvertibleTo<_Sent> _Sent2>
    constexpr common_iterator(const common_iterator<_Iter2, _Sent2>& __x)
        : __v_{__x.__v_.__index_ == 1
            ? _Variant{in_place_index<1>, __x.__v_.__iter_}
            : __x.__v_.__index == 2
                ? _Variant{in_place_index<2>, __x.__v_.__sent_}
                : _Variant{in_place_index<2>}}
    {}

    template <ConvertibleTo<_Iter> _Iter2, ConvertibleTo<_Sent> _Sent2>
    common_iterator& operator=(const common_iterator<_Iter2, _Sent2>& __x)
    { __v_ = __x.__v_; return *this; }

    decltype(auto) operator*() { return *__v_.__iter_; }
    decltype(auto) operator*() const requires __dereferenceable<const _Iter>
    { return *__v_.__iter_; }
    decltype(auto) operator->() const requires Readable<const _Iter> &&
        (is_reference_v<iter_reference_t<_Iter>> || __has_op_arrow<const _Iter&> ||
         Constructible<iter_value_t<_Iter>, iter_reference_t<_Iter>>)
    {
        if constexpr (is_pointer_v<_Iter> || __has_op_arrow<const _Iter&>) {
            return __v_.__iter_;
        } else if constexpr (is_reference_v<iter_reference_t<_Iter>>) {
            auto&& __tmp = *__v_.__iter_;
            return _VSTD::addressof(__tmp);
        } else {
            return __common_iterator_detail::__proxy<iter_value_t<_Iter>>(*__v_.__iter_);
        }
    }

    common_iterator& operator++() { ++__v_.__iter_; return *this; }
    decltype(auto) operator++(int)
    {
        if constexpr (ForwardIterator<_Iter>) {
            auto __tmp = *this;
            ++__v_.__iter_;
            return __tmp;
        } else {
            return __v_.__iter_++;
        }
    }

    template <class _Iter2, Sentinel<_Iter> _Sent2>
    requires Sentinel<_Sent, _Iter2>
    friend bool operator==(
        const common_iterator& __x, const common_iterator<_Iter2, _Sent2>& __y)
    {
        auto const __i = __x.__v_.__index_;
        auto const __d = __i ^ __y.__v_.__index_;
        switch (__d) {
        case 0: // indices are equal
            if (__i == 1) {
                if constexpr (EqualityComparableWith<_Iter, _Iter2>) {
                    return __x.__v_.__iter_ == __y.__v_.__iter_;
                }
            }
            return true;

        case 3: // indices are valid and unequal
            if (__i == 1) return __x.__v_.__iter_ == __y.__v_.__sent_;
            else return __x.__v_.__sent_ == __y.__v_.__iter_;

        default: // Precondition violation: don't care
            break;
        }

        return false;
    }

    template <class _Iter2, Sentinel<_Iter> _Sent2>
    requires Sentinel<_Sent, _Iter2>
    friend bool operator!=(
        const common_iterator& __x, const common_iterator<_Iter2, _Sent2>& __y)
    { return !(__x == __y); }

    template <SizedSentinel<_Iter> _Iter2, SizedSentinel<_Iter> _Sent2>
    requires SizedSentinel<_Sent, _Iter2>
    friend iter_difference_t<_Iter2> operator-(
        const common_iterator& __x, const common_iterator<_Iter2, _Sent2>& __y)
    {
        const auto __i = __x.__v_.__index_;
        const auto __d = __i ^ __y.__v_.__index_;
        switch (__d) {
        case 0: // indices are equal
            if (__i == 0) return __x.__v_.__iter_ - __y.__v_.__iter_;
            break;

        case 3: // indices are valid and unequal
            if (__i == 0) return __x.__v_.__iter_ - __y.__v_.__sent_;
            else return __x.__v_.__sent_ - __y.__v_.__iter_;

        default: // Precondition violation: don't care
            break;
        }

        return 0;
    }

    friend iter_rvalue_reference_t<_Iter> iter_move(const common_iterator& __x)
        _NOEXCEPT_(noexcept(_VSTD::ranges::iter_move(__x.__v_.__iter_)))
    { return _VSTD::ranges::iter_move(__x.__v_.__iter_); }

    template <IndirectlySwappable<_Iter> _Iter2, class _Sent2>
    friend void iter_swap(const common_iterator& __x, const common_iterator<_Iter2, _Sent2>& __y)
        _NOEXCEPT_(noexcept(_VSTD::ranges::iter_swap(__x.__v_.__iter_, __y.__v_.__iter_)))
    { return _VSTD::ranges::iter_swap(__x.__v_.__iter_, __y.__v_.__iter_); }
};

template <Readable _Iter, class _Sent>
struct readable_traits<common_iterator<_Iter, _Sent>>
{
    using value_type = iter_value_t<_Iter>;
};

template <class>
struct __common_iter_traits_pointer
{
    using pointer = void;
};

template <class _Tp>
requires __has_op_arrow<const _Tp&>
struct __common_iter_traits_pointer<_Tp>
{
    using pointer = decltype(_VSTD::declval<const _Tp&>().operator->());
};

template <InputIterator _Iter, class _Sent>
struct iterator_traits<common_iterator<_Iter, _Sent>>
    : __common_iter_traits_pointer<common_iterator<_Iter, _Sent>>
{
    using difference_type = iter_difference_t<_Iter>;
    using value_type = iter_value_t<_Iter>;
    using reference = iter_reference_t<_Iter>;
    using iterator_category = __select<
        DerivedFrom<typename iterator_traits<_Iter>::iterator_category, forward_iterator_tag>,
        forward_iterator_tag, input_iterator_tag>;
    using iterator_concept =
        __select<ForwardIterator<_Iter>, forward_iterator_tag, input_iterator_tag>;
};

template <Iterator _Iter>
class counted_iterator {
private:
    template <class> friend struct counted_iterator;

    _Iter __current_{};
    iter_difference_t<_Iter> __count_ = 0;

public:
    using iterator_type = _Iter;
    using difference_type = iter_difference_t<_Iter>;

    constexpr counted_iterator() = default;
    constexpr counted_iterator(_Iter __x, iter_difference_t<_Iter> __n)
        : __current_(__x), __count_(__n) {}
    template <ConvertibleTo<_Iter> _Iter2>
    constexpr counted_iterator(const counted_iterator<_Iter2>& __x)
        : __current_(__x), __count_(__x.__count_) {}

    template <ConvertibleTo<_Iter> _Iter2>
    constexpr counted_iterator& operator=(const counted_iterator<_Iter2>& __x)
    {
        __current_ = __x.__current_;
        __count_ = __x.__count_;
        return *this;
    }

    constexpr _Iter base() const
    { return __current_; }

    constexpr iter_difference_t<_Iter> count() const
    { return __count_; }

    constexpr decltype(auto) operator*()
    { return *__current_; }
    constexpr decltype(auto) operator*() const
        requires __dereferenceable<const _Iter>
    { return *__current_; }

    constexpr counted_iterator& operator++()
    { ++__current_; --__count_; return *this; }
    constexpr decltype(auto) operator++(int)
        requires ForwardIterator<_Iter>
#ifndef _LIBCPP_NO_EXCEPTIONS
            || _NOEXCEPT_(__current_++)
#endif
    {
        if constexpr (ForwardIterator<_Iter>) {
            auto __tmp = *this;
            ++*this;
            return __tmp;
        } else {
            --__count_;
            return __current_++;
        }
    }
#ifndef _LIBCPP_NO_EXCEPTIONS
    decltype(auto) operator++(int)
    {
        --__count_;
        try {
            return __current_++;
        } catch (...) {
            ++__count_;
            throw;
        }
    }
#endif

    constexpr counted_iterator& operator--() requires BidirectionalIterator<_Iter>
    { --__current_; ++__count_; return *this; }
    constexpr counted_iterator operator--(int) requires BidirectionalIterator<_Iter>
    {
        auto __tmp = *this;
        --*this;
        return __tmp;
    }

    constexpr counted_iterator operator+(difference_type __n) const
        requires RandomAccessIterator<_Iter>
    { return counted_iterator(__current_ + __n, __count_ - __n); }
    friend constexpr counted_iterator operator+(
        iter_difference_t<_Iter> __n, const counted_iterator& __x)
            requires RandomAccessIterator<_Iter>
    { return __x + __n; }
    constexpr counted_iterator& operator+=(difference_type __n)
        requires RandomAccessIterator<_Iter>
    { __current_ += __n; __count_ -= __n; }

    constexpr counted_iterator operator-(difference_type __n) const
        requires RandomAccessIterator<_Iter>
    { return counted_iterator(__current_ - __n, __count_ + __n); }
    template <Common<_Iter> _Iter2>
    friend constexpr iter_difference_t<_Iter2> operator-(
        const counted_iterator& __x, const counted_iterator<_Iter2>& __y)
    { return __y.__count_ - __x.__count_; }
    friend constexpr iter_difference_t<_Iter> operator-(
        const counted_iterator& __x, default_sentinel)
    { return -__x.__count_; }
    friend constexpr iter_difference_t<_Iter> operator-(
        default_sentinel, const counted_iterator& __y)
    { return __y.__count_; }
    constexpr counted_iterator& operator-=(difference_type __n)
        requires RandomAccessIterator<_Iter>
    { __current_ -= __n; __count_ += __n; }

    constexpr decltype(auto) operator[](difference_type __n) const
        requires RandomAccessIterator<_Iter>
    { return __current_[__n]; }

    template <Common<_Iter> _Iter2>
    friend constexpr bool operator==(
        const counted_iterator& __x, const counted_iterator<_Iter2>& __y)
    { return __x.__count_ == __y.__count_; }
    friend constexpr bool operator==(
        const counted_iterator& __x, default_sentinel)
    { return __x.__count_ == 0; }
    friend constexpr bool operator==(
        default_sentinel, const counted_iterator& __x)
    { return __x.__count_ == 0; }

    template <Common<_Iter> _Iter2>
    friend constexpr bool operator!=(
        const counted_iterator& __x, const counted_iterator<_Iter2>& __y)
    { return !(__x == __y); }
    friend constexpr bool operator!=(
        const counted_iterator& __x, default_sentinel __y)
    { return !(__x == __y); }
    friend constexpr bool operator!=(
        default_sentinel __x, const counted_iterator& __y)
    { return !(__x == __y); }

    template <Common<_Iter> _Iter2>
    friend constexpr bool operator<(
        const counted_iterator& __x, const counted_iterator<_Iter2>& __y)
    { return __y.__count_ < __x.__count_; }
    template <Common<_Iter> _Iter2>
    friend constexpr bool operator>(
        const counted_iterator& __x, const counted_iterator<_Iter2>& __y)
    { return __y < __x; }
    template <Common<_Iter> _Iter2>
    friend constexpr bool operator<=(
        const counted_iterator& __x, const counted_iterator<_Iter2>& __y)
    { return !(__y < __x); }
    template <Common<_Iter> _Iter2>
    friend constexpr bool operator>=(
        const counted_iterator& __x, const counted_iterator<_Iter2>& __y)
    { return !(__x < __y); }

    friend constexpr iter_rvalue_reference_t<_Iter> iter_move(const counted_iterator& __x)
    _NOEXCEPT_(noexcept(_VSTD::ranges::iter_move(__x.__current_)))
    requires InputIterator<_Iter>
    { return _VSTD::ranges::iter_move(__x.__current_); }

    template <IndirectlySwappable<_Iter> _Iter2>
    friend constexpr void iter_swap(const counted_iterator& __x, const counted_iterator<_Iter2>& __y)
    _NOEXCEPT_(noexcept(_VSTD::ranges::iter_swap(__x.__current_, __y.__current_)))
    { return _VSTD::ranges::iter_swap(__x.__current_, __y.__current_); }
};

template <Readable _Iter>
struct readable_traits<counted_iterator<_Iter>> {
    using value_type = iter_value_t<_Iter>;
};

template <InputIterator _Iter>
struct iterator_traits<counted_iterator<_Iter>>
    : iterator_traits<_Iter>
{
    using pointer = void;
};

struct unreachable {
    template <WeaklyIncrementable _Iter>
    friend constexpr bool operator==(unreachable, const _Iter&) _NOEXCEPT
    { return false; }
    template <WeaklyIncrementable _Iter>
    friend constexpr bool operator==(const _Iter&, unreachable) _NOEXCEPT
    { return false; }
    template <WeaklyIncrementable _Iter>
    friend constexpr bool operator!=(unreachable, const _Iter&) _NOEXCEPT
    { return true; }
    template <WeaklyIncrementable _Iter>
    friend constexpr bool operator!=(const _Iter&, unreachable) _NOEXCEPT
    { return true; }
};
#endif // _LIBCPP_HAS_RANGES

// __wrap_iter

template <class _Iter> class __wrap_iter;

template <class _Iter1, class _Iter2>
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;

template <class _Iter1, class _Iter2>
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;

template <class _Iter1, class _Iter2>
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;

template <class _Iter1, class _Iter2>
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;

template <class _Iter1, class _Iter2>
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;

template <class _Iter1, class _Iter2>
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;

#ifndef _LIBCPP_CXX03_LANG
template <class _Iter1, class _Iter2>
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
auto
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
-> decltype(__x.base() - __y.base());
#else
template <class _Iter1, class _Iter2>
_LIBCPP_INLINE_VISIBILITY
typename __wrap_iter<_Iter1>::difference_type
operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
#endif

template <class _Iter>
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT_DEBUG;

template <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);
template <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);

#if _LIBCPP_DEBUG_LEVEL < 2

template <class _Tp>
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*>);

#else

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    __wrap_iter<_Tp*>
>::type
__unwrap_iter(__wrap_iter<_Tp*> __i);

#endif

template <class _Iter>
class __wrap_iter
{
public:
    typedef _Iter                                                      iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type        value_type;
    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;
    typedef typename iterator_traits<iterator_type>::pointer           pointer;
    typedef typename iterator_traits<iterator_type>::reference         reference;
#ifdef _LIBCPP_HAS_RANGES
    using iterator_concept =
        __select<ContiguousIterator<_Iter>, contiguous_iterator_tag, iterator_category>;
#endif
private:
    iterator_type __i;
public:
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter() _NOEXCEPT_DEBUG
#if _LIBCPP_STD_VER > 11
                : __i{}
#endif
    {
#if _LIBCPP_DEBUG_LEVEL >= 2
        __get_db()->__insert_i(this);
#endif
    }
    template <class _Up> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
        __wrap_iter(const __wrap_iter<_Up>& __u,
            typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT_DEBUG
            : __i(__u.base())
    {
#if _LIBCPP_DEBUG_LEVEL >= 2
        __get_db()->__iterator_copy(this, &__u);
#endif
    }
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_INLINE_VISIBILITY
    __wrap_iter(const __wrap_iter& __x)
        : __i(__x.base())
    {
        __get_db()->__iterator_copy(this, &__x);
    }
    _LIBCPP_INLINE_VISIBILITY
    __wrap_iter& operator=(const __wrap_iter& __x)
    {
        if (this != &__x)
        {
            __get_db()->__iterator_copy(this, &__x);
            __i = __x.__i;
        }
        return *this;
    }
    _LIBCPP_INLINE_VISIBILITY
    ~__wrap_iter()
    {
        __get_db()->__erase_i(this);
    }
#endif
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG reference operator*() const _NOEXCEPT_DEBUG
    {
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),
                       "Attempted to dereference a non-dereferenceable iterator");
#endif
        return *__i;
    }
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG pointer  operator->() const _NOEXCEPT_DEBUG
    {
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),
                       "Attempted to dereference a non-dereferenceable iterator");
#endif
        return (pointer)_VSTD::addressof(*__i);
    }
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter& operator++() _NOEXCEPT_DEBUG
    {
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),
                       "Attempted to increment non-incrementable iterator");
#endif
        ++__i;
        return *this;
    }
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter  operator++(int) _NOEXCEPT_DEBUG
        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}

    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter& operator--() _NOEXCEPT_DEBUG
    {
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),
                       "Attempted to decrement non-decrementable iterator");
#endif
        --__i;
        return *this;
    }
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter  operator--(int) _NOEXCEPT_DEBUG
        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT_DEBUG
        {__wrap_iter __w(*this); __w += __n; return __w;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter& operator+=(difference_type __n) _NOEXCEPT_DEBUG
    {
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),
                   "Attempted to add/subtract iterator outside of valid range");
#endif
        __i += __n;
        return *this;
    }
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter  operator- (difference_type __n) const _NOEXCEPT_DEBUG
        {return *this + (-__n);}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter& operator-=(difference_type __n) _NOEXCEPT_DEBUG
        {*this += -__n; return *this;}
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG reference    operator[](difference_type __n) const _NOEXCEPT_DEBUG
    {
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),
                   "Attempted to subscript iterator outside of valid range");
#endif
        return __i[__n];
    }

    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG iterator_type base() const _NOEXCEPT_DEBUG {return __i;}

private:
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)
    {
        __get_db()->__insert_ic(this, __p);
    }
#else
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG __wrap_iter(iterator_type __x) _NOEXCEPT_DEBUG : __i(__x) {}
#endif

    template <class _Up> friend class __wrap_iter;
    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
    template <class _Tp, class _Alloc> friend class _LIBCPP_TEMPLATE_VIS vector;
    template <class _Tp, ptrdiff_t> friend class _LIBCPP_TEMPLATE_VIS span;

    template <class _Iter1, class _Iter2>
    _LIBCPP_CONSTEXPR_IF_NODEBUG friend
    bool
    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;

    template <class _Iter1, class _Iter2>
    _LIBCPP_CONSTEXPR_IF_NODEBUG friend
    bool
    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;

    template <class _Iter1, class _Iter2>
    _LIBCPP_CONSTEXPR_IF_NODEBUG friend
    bool
    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;

    template <class _Iter1, class _Iter2>
    _LIBCPP_CONSTEXPR_IF_NODEBUG friend
    bool
    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;

    template <class _Iter1, class _Iter2>
    _LIBCPP_CONSTEXPR_IF_NODEBUG friend
    bool
    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;

    template <class _Iter1, class _Iter2>
    _LIBCPP_CONSTEXPR_IF_NODEBUG friend
    bool
    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;

#ifndef _LIBCPP_CXX03_LANG
    template <class _Iter1, class _Iter2>
    _LIBCPP_CONSTEXPR_IF_NODEBUG friend
    auto
    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
    -> decltype(__x.base() - __y.base());
#else
    template <class _Iter1, class _Iter2>
    _LIBCPP_CONSTEXPR_IF_NODEBUG friend
    typename __wrap_iter<_Iter1>::difference_type
    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
#endif

    template <class _Iter1>
    _LIBCPP_CONSTEXPR_IF_NODEBUG friend
    __wrap_iter<_Iter1>
    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT_DEBUG;

    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);

#if _LIBCPP_DEBUG_LEVEL < 2
    template <class _Tp>
    _LIBCPP_CONSTEXPR_IF_NODEBUG friend
    typename enable_if
    <
        is_trivially_copy_assignable<_Tp>::value,
        _Tp*
    >::type
    __unwrap_iter(__wrap_iter<_Tp*>);
#else
  template <class _Tp>
  inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
  typename enable_if
  <
      is_trivially_copy_assignable<_Tp>::value,
      __wrap_iter<_Tp*>
  >::type
  __unwrap_iter(__wrap_iter<_Tp*> __i);
#endif
};

template <class _Iter1, class _Iter2>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
{
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),
                   "Attempted to compare incomparable iterators");
#endif
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
{
    return !(__x == __y);
}

template <class _Iter1, class _Iter2>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
{
    return __y < __x;
}

template <class _Iter1, class _Iter2>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
{
    return !(__x < __y);
}

template <class _Iter1, class _Iter2>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
{
    return !(__y < __x);
}

template <class _Iter1>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG
{
    return !(__x == __y);
}

template <class _Iter1>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG
{
    return __y < __x;
}

template <class _Iter1>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG
{
    return !(__x < __y);
}

template <class _Iter1>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG
{
    return !(__y < __x);
}

#ifndef _LIBCPP_CXX03_LANG
template <class _Iter1, class _Iter2>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
auto
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
-> decltype(__x.base() - __y.base())
{
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),
                   "Attempted to subtract incompatible iterators");
#endif
    return __x.base() - __y.base();
}
#else
template <class _Iter1, class _Iter2>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
typename __wrap_iter<_Iter1>::difference_type
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
{
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),
                   "Attempted to subtract incompatible iterators");
#endif
    return __x.base() - __y.base();
}
#endif

template <class _Iter>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_IF_NODEBUG
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type __n,
          __wrap_iter<_Iter> __x) _NOEXCEPT_DEBUG
{
    __x += __n;
    return __x;
}

template <class _Iter>
struct __libcpp_is_trivial_iterator
    : public _LIBCPP_BOOL_CONSTANT(is_pointer<_Iter>::value) {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<move_iterator<_Iter> >
    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >
    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >
    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};

#ifdef _LIBCPP_HAS_RANGES
template <class _Iter>
struct __libcpp_is_trivial_iterator<counted_iterator<_Iter> >
    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};
#endif // _LIBCPP_HAS_RANGES

template <class _Tp, size_t _Np>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
_Tp*
begin(_Tp (&__array)[_Np])
{
    return __array;
}

template <class _Tp, size_t _Np>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
_Tp*
end(_Tp (&__array)[_Np])
{
    return __array + _Np;
}

#if !defined(_LIBCPP_CXX03_LANG)

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
auto
begin(_Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
auto
begin(const _Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
auto
end(_Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
auto
end(const _Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}

#if _LIBCPP_STD_VER > 11

template <class _Tp, size_t _Np>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
reverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array + _Np);
}

template <class _Tp, size_t _Np>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
reverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array);
}

template <class _Ep>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
reverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.end());
}

template <class _Ep>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
reverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.begin());
}

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
auto cbegin(const _Cp& __c) -> decltype(_VSTD::begin(__c))
{
    return _VSTD::begin(__c);
}

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
auto cend(const _Cp& __c) -> decltype(_VSTD::end(__c))
{
    return _VSTD::end(__c);
}

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
auto rbegin(_Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
auto rbegin(const _Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
auto rend(_Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
auto rend(const _Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
auto crbegin(const _Cp& __c) -> decltype(_VSTD::rbegin(__c))
{
    return _VSTD::rbegin(__c);
}

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
auto crend(const _Cp& __c) -> decltype(_VSTD::rend(__c))
{
    return _VSTD::rend(__c);
}

#endif


#else  // defined(_LIBCPP_CXX03_LANG)

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY
typename _Cp::iterator
begin(_Cp& __c)
{
    return __c.begin();
}

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY
typename _Cp::const_iterator
begin(const _Cp& __c)
{
    return __c.begin();
}

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY
typename _Cp::iterator
end(_Cp& __c)
{
    return __c.end();
}

template <class _Cp>
inline _LIBCPP_INLINE_VISIBILITY
typename _Cp::const_iterator
end(const _Cp& __c)
{
    return __c.end();
}

#endif  // !defined(_LIBCPP_CXX03_LANG)

#if _LIBCPP_STD_VER > 14

// #if _LIBCPP_STD_VER > 11
// template <>
// struct _LIBCPP_TEMPLATE_VIS plus<void>
// {
//     template <class _T1, class _T2>
//     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
//     auto operator()(_T1&& __t, _T2&& __u) const
//     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u)))
//     -> decltype        (_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u))
//         { return        _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }
//     typedef void is_transparent;
// };
// #endif

template <class _Cont>
inline _LIBCPP_INLINE_VISIBILITY
constexpr auto size(const _Cont& __c)
_NOEXCEPT_(noexcept(__c.size()))
-> decltype        (__c.size())
{ return            __c.size(); }

template <class _Tp, size_t _Sz>
inline _LIBCPP_INLINE_VISIBILITY
constexpr size_t size(const _Tp (&)[_Sz]) noexcept { return _Sz; }

template <class _Cont>
_LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY
constexpr auto empty(const _Cont& __c)
_NOEXCEPT_(noexcept(__c.empty()))
-> decltype        (__c.empty())
{ return            __c.empty(); }

template <class _Tp, size_t _Sz>
_LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY
constexpr bool empty(const _Tp (&)[_Sz]) noexcept { return false; }

template <class _Ep>
_LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY
constexpr bool empty(initializer_list<_Ep> __il) noexcept { return __il.size() == 0; }

template <class _Cont> constexpr
inline _LIBCPP_INLINE_VISIBILITY
auto data(_Cont& __c)
_NOEXCEPT_(noexcept(__c.data()))
-> decltype        (__c.data())
{ return            __c.data(); }

template <class _Cont> constexpr
inline _LIBCPP_INLINE_VISIBILITY
auto data(const _Cont& __c)
_NOEXCEPT_(noexcept(__c.data()))
-> decltype        (__c.data())
{ return            __c.data(); }

template <class _Tp, size_t _Sz>
inline _LIBCPP_INLINE_VISIBILITY
constexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept { return __array; }

template <class _Ep>
inline _LIBCPP_INLINE_VISIBILITY
constexpr const _Ep* data(initializer_list<_Ep> __il) noexcept { return __il.begin(); }
#endif

_LIBCPP_END_NAMESPACE_STD

#endif  // _LIBCPP_ITERATOR
